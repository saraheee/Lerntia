(1) Welche Modellierungen sind korrekt für den angegebenen Sachverhalt? [Jede Person hat einen Namen (NAME), ein Geburtsdatum (GEBDAT), sowie eine e-mail Adresse (EMAIL), wobei es keine zwei Personen mit demselben Namen gibt, welche am selben Tag geboren wurden.];(1. ) Die erste Modellierung.;(2. ) Die zweite Modellierung.;(3. ) Die dritte Modellierung.;(4. ) Die vierte Modellierung.;Keine der genannten Antworten.;4;mod1.png;
(2) Welche Modellierungen sind korrekt für den angegebenen Sachverhalt? [Zu jedem Vorsatz wird das Jahr (JAHR), eine kurze Bezeichnung (SLOGAN), sowie eine ID (ID) gespeichert, wobei sowohl der Slogan als auch die ID eindeutig für jeden Vorsatz sind.];(1. ) Die erste Modellierung.;(2. ) Die zweite Modellierung.;(3. ) Die dritte Modellierung.;(4. ) Die vierte Modellierung.;Keine der genannten Antworten.;24;mod2.png;
(3) Welche Modellierungen sind korrekt für den angegebenen Sachverhalt? [Jede Person kann bei maximal einem Vorsatz von maximal einer weiteren Person unterstützt werden, wobei eine Person beliebig viele andere Personen unterstützen darf. Dabei muss klar erkennbar sein, welche Person die unterstützende, und welche die unterstützte ist.];(1. ) Die erste Modellierung.;(2. ) Die zweite Modellierung.;(3. ) Die dritte Modellierung.;(4. ) Die vierte Modellierung.;Keine der genannten Antworten.;1;mod3.png;
(4) Welche Modellierungen sind korrekt für den angegebenen Sachverhalt? [Jeder Vorsatz enthält mindestens ein Ziel. Für jedes in einem Vorsatz enthaltene Ziel wird eine Priorität (PRIORITAET) vermerkt, wobei ein Ziel in mehreren Vorsätzen vorkommen kann.];(1. ) Die erste Modellierung.;(2. ) Die zweite Modellierung.;(3. ) Die dritte Modellierung.;(4. ) Die vierte Modellierung.;Keine der genannten Antworten.;3;mod4.png;
(5) Welche Modellierungen sind korrekt für den angegebenen Sachverhalt? [Ein Ziel hat einen Namen (NAME) und ein Level (LEVEL), die zusammen eindeutig sind. Immer, wenn ein aktives Ziel erreicht wird, wird ein Datum (DATUM) und ein Kommentar (KOMMENTAR) gespeichert. Dasselbe aktive Ziel kann am selben Datum maximal einmal erreicht werden. Nicht jedes Ziel muss aktiv sein.];(1. ) Die erste Modellierung.;(2. ) Die zweite Modellierung.;(3. ) Die dritte Modellierung.;(4. ) Die vierte Modellierung.;Keine der genannten Antworten.;2;mod5.png;
(6) Welche Aussagen sind korrekt für das EER Diagramm im Bild?;Ein U wird mittels u1 und u2 eindeutig beschrieben.;Ein F kann ohne U nicht existieren.;Ein F ist in der h Beziehung genau einem U zugeordnet.;Für jedes B muss b1 eindeutig sein.;Keine der genannten Antworten.;5;eer.png;
(7) Welche Aussagen sind korrekt für das EER Diagramm im Bild?;Ein U kann ohne F nicht existieren.;Ein U ist in der h Beziehung genau einem F zugeordnet.;Für jedes U müssen genau ein I und ein F an der j Beziehung teilnehmen.;Ein F wird über i2 eindeutig beschrieben.;Keine der genannten Antworten.;123;eer.png;
(8) Welche Aussagen sind korrekt für das EER Diagramm im Bild?;Für jedes B kann es keine zwei gleichen b2 Werte geben.;Jedes B kann eine n Beziehung mit bis zu zwei U eingehen.;Ein F wird über i1 und i2 zusammen eindeutig beschrieben.;Für jedes F müssen genau ein I und ein U an der j Beziehung teilnehmen.;Keine der genannten Antworten.;3;eer.png;
(9) Welche Aussagen sind korrekt für das EER Diagramm im Bild?;Jedes I muss mindestens eine g Beziehung mit einem B eingehen.;Jedes I kann maximal zwei g Beziehungen mit einem B eingehen.;Jedes I muss an mindestens einer j Beziehung teilnehmen.;Jedes I hat ein f1 und ein f2.;Keine der genannten Antworten.;2;eer.png;
(10) Welche Übersetzungen sind korrekt für I im Bild? Keine Nullwerte erlaubt.;(1. ) Die erste Übersetzung. [i1 unterstrichen, i2 unterstrichen, i3];(2. ) Die zweite Übersetzung. [i1 unterstrichen, i2 unterstrichen, i3, B.b1, B.b2];(3. ) Die dritte Übersetzung. [i1 unterstrichen, i2 unterstrichen, i3, B.b1 unterstrichen, B.b2 unterstrichen, B.b3];(4. ) Die vierte Übersetzung. [i1 unterstrichen, i2 unterstrichen, i3, B.b1, B.b2, U.u1, U.u2];Keine der genannten Antworten.;1;eer1.png;
(11) Welche Übersetzungen sind korrekt für g im Bild? Keine Nullwerte erlaubt.;(1. ) Die erste Übersetzung. [g1, I.i1 unterstrichen, I.i2 unterstrichen];(2. ) Die zweite Übersetzung. [g1, B.b1 unterstrichen, B.b2 unterstrichen];(3. ) Die dritte Übersetzung. [g1, B.b1 unterstrichen, B.b2 unterstrichen, I.i1 unterstrichen, I.i2 unterstrichen];(4. ) Die vierte Übersetzung. [g1, B.b1, B.b2, I.i1 unterstrichen, I.i2 unterstrichen];Keine der genannten Antworten.;3;eer2.png;
(12) Welche Übersetzungen sind korrekt für F im Bild? Keine Nullwerte erlaubt.;(1. ) Die erste Übersetzung. [f1, f2];(2. ) Die zweite Übersetzung. [f1, f2, I.i1 unterstrichen, I.i2 unterstrichen];(3. ) Die dritte Übersetzung. [f1, f2, I.i1 unterstrichen, I.i2 unterstrichen, I.i3];(4. ) Die vierte Übersetzung. [f1, f2, I.i1 unterstrichen, I.i2 unterstrichen, I.i3, U.u1 unterstrichen, U.u2 unterstrichen];Keine der genannten Antworten.;2;eer3.png;
(13) Welche Übersetzungen sind korrekt für U im Bild? Keine Nullwerte erlaubt.;(1. ) Die erste Übersetzung. [u1, u2, u3];(2. ) Die zweite Übersetzung. [u1 unterstrichen, u2 unterstrichen, u3, F.i1 unterstrichen, F.i2 unterstrichen];(3. ) Die dritte Übersetzung. [u1 unterstrichen, u2 unterstrichen, u3, F.i1 unterstrichen, F.i2 unterstrichen, I.i1, I.i2];(4. ) Die vierte Übersetzung. [u1 unterstrichen, u2 unterstrichen, u3, F.i1 unterstrichen, F.i2 unterstrichen, I.i1, I.i2, F.i1, F.i2];Keine der genannten Antworten.;4;eer4.png;
(14) Welche Übersetzungen sind korrekt für n im Bild? Keine Nullwerte erlaubt.;(1. ) Die erste Übersetzung. [B.b1 unterstrichen, B.b2 unterstrichen];(2. ) Die zweite Übersetzung. [B.b1 unterstrichen, B.b2 unterstrichen, B.b3, U.u1 unterstrichen, U.u2 unterstrichen, U.u3];(3. ) Die dritte Übersetzung. [B.b1 unterstrichen, B.b2 unterstrichen, U.u1, U.u2, U.i1, U.i2];(4. ) Die vierte Übersetzung.(4. ) Die vierte Übersetzung. [B.b1 unterstrichen, B.b2 unterstrichen, U.u1 unterstrichen, U.u2 unterstrichen, U.i1 unterstrichen, U.i2 unterstrichen];Keine der genannten Antworten.;3;eer5.png;
(15) Was liefert die Abfrage im Bild zurück?;Die Namen aller Actionfilme, die von allen Kunden gesehen wurden.;Die Namen aller Actionfilme, die von keinen Kunden gesehen wurden.;Die ids jener Kunden, die jeden Actionfilm gesehen haben.;Die ids jener Kunden, die keinen Actionfilm gesehen haben.;Keine der genannten Antworten.;3;rel1.png;
(16) Was liefert die Abfrage im Bild zurück?;MalerInnen deren Kunstwerke nur Teil von Ausstellungen in MUMOK waren.;MalerInnen deren Kunstwerke kein Teil von Ausstellungen in MUMOK waren.;Namen der MalerInnen mit Kunstwerken, die in MUMOK ausgestellt sind.;Namen der Kunstwerke von MalerInnen, die nie Teil der Ausstellung in MUMOK waren.;Keine der genannten Antworten.;1;rel2.png;
(17) Was liefert die Abfrage im Bild zurück?;Die PID aller Personen, die aus jeder Bibliothek maximal ein Buch ausgeliehen haben.;Die Namen aller Personen, die aus jeder Bibliothek zumindest ein Buch ausgeliehen haben.;Die Namen aller Personen, die aus mindestens einer Bibliothek genau ein Buch ausgeliehen haben.;Die BID aller Bücher, die zumindest einmal von einer Person ausgeliehen wurden.;Keine der genannten Antworten.;2;rel3.png;
(18) Welche Werte liefert die Abfrage im Bild zurück?;[ kname = 'Alpha ',  kid = 'A ' ];[ kname = 'Bravo ',  kid = 'B ' ];[ kname = 'Charlie ',  kid = 'C ' ];[ kname = 'Delta ', kid = 'D ' ];[ kname = 'Echo ', kid = 'E ' ];145;rel4.png;
(19) Welche Abfragen im Tupelkalkül geben die Information im Bild aus? [Es sollen die Namen jener Kunden gefunden werden, welche schon mindestens einen Film mit 1 Stern beurteilt haben.];(1. ) Die erste Abfrage.;(2. ) Die zweite Abfrage.;(3. ) Die dritte Abfrage.;(4. ) Die vierte Abfrage.;Keine der genannten Antworten.;1;rel5.png;
(20) Welche Abfragen im Domänenkalkül geben die Information im Bild aus? [Es sollen jene Kunstwerke (KID und Name) abgefragt werden, die noch nie in einem Museum in Wien ausgestellt wurden.];(1. ) Die erste Abfrage.;(2. ) Die zweite Abfrage.;(3. ) Die dritte Abfrage.;(4. ) Die vierte Abfrage.;Keine der genannten Antworten.;4;rel6.png;
(21) Was ist die minimale und maximale Größe des Ausdrucks im Bild?;Minimal 0, und maximal 3;Minimal 5, und maximal 8;Minimal 3, und maximal 8;Minimal 3, und maximal 11;Keine der genannten Antworten.;2;gr1.png;
(22) Was ist die minimale und maximale Größe des Ausdrucks im Bild?;Minimal 0, und maximal 8;Minimal 3, und maximal 8;Minimal 8, und maximal 8;Minimal 8, und maximal 11;Keine der genannten Antworten.;3;gr2.png;
(23) Was ist die minimale und maximale Größe des Ausdrucks im Bild?;Minimal 0, und maximal 3;Minimal 3, und maximal 10;Minimal 0, und maximal 20;Minimal 0, und maximal 30;Keine der genannten Antworten.;4;gr3.png;
(24) Was ist die minimale und maximale Größe des Ausdrucks im Bild?;Minimal 0, und maximal 3;Minimal 0, und maximal 7;Minimal 3, und maximal 4;Minimal 3, und maximal 7;Keine der genannten Antworten.;1;gr4.png;
(25) Was ist die minimale und maximale Größe des Ausdrucks im Bild?;Minimal 0, und maximal 3;Minimal 0, und maximal 7;Minimal 3, und maximal 4;Minimal 3, und maximal 7;Keine der genannten Antworten.;4;gr5.png;
(26) Welche Aussagen sind korrekt für die funktionale Abhängigkeit F im Bild?;F ist für die gegebene Ausprägung erfüllt.;F ist für die gegebene Ausprägung nicht erfüllt.;F ist nach Löschen von Zeile 3 erfüllt. ;F ist nach Löschen von Zeile 6 erfüllt. ;Keine der genannten Antworten.;234;fd1.png;Eine funktionale Abhängigkeit alpha -> beta ist in einer Relation erfüllt, wenn die alpha-Werte die beta-Werte eindeutig (funktional) bestimmen. Wenn zwei Tupel die gleichen Werte für alle Attribute in alpha haben, so müssen sie auch die gleichen Werte für alle Attribute in beta haben.
(27) Welche Aussagen sind korrekt für die funktionale Abhängigkeit F im Bild?;F ist für die gegebene Ausprägung erfüllt.;F ist für die gegebene Ausprägung nicht erfüllt.;F ist nach Löschen von Zeile 4 erfüllt. ;F ist nach Löschen von Zeile 6 erfüllt. ;Keine der genannten Antworten.;24;fd2.png;Eine funktionale Abhängigkeit alpha -> beta ist in einer Relation erfüllt, wenn die alpha-Werte die beta-Werte eindeutig (funktional) bestimmen. Wenn zwei Tupel die gleichen Werte für alle Attribute in alpha haben, so müssen sie auch die gleichen Werte für alle Attribute in beta haben.
(28) Welche Aussagen sind korrekt für die funktionale Abhängigkeit F im Bild?;F ist für die gegebene Ausprägung erfüllt.;F ist für die gegebene Ausprägung nicht erfüllt.;F ist nach Löschen von Zeile 5 erfüllt. ;F ist nach Löschen von Zeile 6 erfüllt. ;Keine der genannten Antworten.;134;fd3.png;Wenn eine Funktionale Abhängigkeit erfüllt ist, so ist diese auch durch Löschen beliebiger Tupel weiterhin erfüllt. 
(29) Welche Aussagen sind korrekt für die funktionale Abhängigkeit F im Bild?;F ist für die gegebene Ausprägung erfüllt.;F ist für die gegebene Ausprägung nicht erfüllt.;F ist nach Hinzufügen von Zusatzzeile 7 zur Ausprägung erfüllt.;F ist nach Hinzufügen von Zusatzzeile 8 zur Ausprägung erfüllt.;Keine der genannten Antworten.;14;fd4.png;Eine funktionale Abhängigkeit alpha -> beta ist in einer Relation erfüllt, wenn die alpha-Werte die beta-Werte eindeutig (funktional) bestimmen. Wenn zwei Tupel die gleichen Werte für alle Attribute in alpha haben, so müssen sie auch die gleichen Werte für alle Attribute in beta haben.
(30) Welche Aussagen sind korrekt für die funktionale Abhängigkeit F im Bild?;F ist für die gegebene Ausprägung erfüllt.;F ist für die gegebene Ausprägung nicht erfüllt.;F ist nach Hinzufügen von Zusatzzeile 7 zur Ausprägung erfüllt.;F ist nach Hinzufügen von Zusatzzeile 8 zur Ausprägung erfüllt.;Keine der genannten Antworten.;134;fd5.png;Ein Attribut ist immer funktional abhängig von sich selbst und von jeder Obermenge von sich selbst. In diesem Fall handelt es sich um eine triviale Abhängigkeit. Diese bleibt auch nach dem Hinzufügen oder Löschen beliebiger Tupel erfüllt.
(31) Sind die funktionalen Abhängigkeiten F1 und F2 im Bild äquivalent?;Ja, F1 und F2 besitzen dieselbe Hülle.;Nein, BD -> CE ist kein Element der Hülle von F1.;Nein, CE -> D ist kein Element der Hülle von F1.;Nein, BD -> AC ist kein Element der Hülle von F2.;Keine der genannten Antworten.;2;eq1.png;Zwei Mengen von funktionalen Abhängigkeiten sind äquivalent, wenn sie dieselbe Hülle besitzen.
(32) Sind die funktionalen Abhängigkeiten F1 und F2 im Bild äquivalent?;Ja, F1 und F2 besitzen dieselbe Hülle.;Nein, A -> BE ist kein Element der Hülle von F2.;Nein, AC -> D ist kein Element der Hülle von F2.;Nein, BC -> D ist kein Element der Hülle von F1.;Keine der genannten Antworten.;4;eq2.png;Zwei Mengen von funktionalen Abhängigkeiten sind äquivalent, wenn sie dieselbe Hülle besitzen.
(33) Sind die funktionalen Abhängigkeiten F1 und F2 im Bild äquivalent?;Ja, F1 und F2 besitzen dieselbe Hülle.;Nein, E -> E ist kein Element der Hülle von F2.;Nein, AB -> D ist kein Element der Hülle von F2.;Nein, A -> C ist kein Element der Hülle von F1.;Keine der genannten Antworten.;1;eq3.png;Zwei Mengen von funktionalen Abhängigkeiten sind äquivalent, wenn sie dieselbe Hülle besitzen. Triviale funktionale Abhängigkeiten sind immer erfüllt, und in jeder Hülle enthalten.
(34) Welche Aussagen über Kanonische Überdeckungen (KÜ) sind richtig?;Es gibt Mengen von FDs, die keine Kanonische Überdeckung haben.;Wenn sie existiert, ist die KÜ einer Menge von FDs eindeutig.;Eine Menge von FDs kann mehrere äquivalente KÜs haben.;Es kann in einer KÜ mehrere FDs mit der gleichen linken Seite geben.;Keine der genannten Antworten.;3;;Bei der Kanonischen Überdeckung KÜ handelt es sich um eine minimale Darstellung der Funktionalen Abhängigkeiten FDs. .... Für jede Menge an Funktionalen Abhängigkeiten existiert also auch eine KÜ. Wenn es keine Redundanzen in ihrer Darstellung mehr gibt, handelt es sich bereits um eine KÜ, wenn nicht, können diese Redundanzen durch Linksreduktion und Rechtsreduktion entfernt werden, um eine KÜ zu erhalten. .... Eine KÜ ist nicht eindeutig, da das Ergebnis davon abhängen kann, in welcher Reihenfolge man die FDs in den Reduktionsschritten entfernt. .... Für dieselbe Menge an FDs kann es somit unterschiedliche KÜs geben, die aber wohlgemerkt alle minimal sind, was bedeutet, dass man nichts mehr entfernen kann, ohne ihre Hülle zu verändern. .... Der erste Schritt vor der Linksreduktion ist die Dekomposition, dabei werden alle FDs so aufgespalten, dass immer nur ein Attribut auf der rechten Seite übrigbleibt. Am Schluss werden die verbleibenden FDs wieder mittels Vereinigungsregel zusammengefasst, sodass jede linke Seite nur einmal vorkommt, um die KÜ kompakter darzustellen.
(35) Welche Aussagen über die Berechnung von KÜs sind richtig?;Der erste Schritt ist die Vereinigung, um die rechte Seite aufzuspalten.;Bei der Linksreduktion können sowohl FDs hinzugefügt als auch entfernt werden.;Bei der Rechtsreduktion werden, wenn angewandt, einzelne Attribute entfernt.;Bei der Rechtsreduktion werden, wenn angewandt, ganze FDs entfernt.;Keine der genannten Antworten.;4;;Die vier Schritte zur Berechnung der Kanonischen Überdeckung sind: Dekomposition, Linksreduktion, Rechtsreduktion, und Vereinigung, in dieser Reihenfolge. .... Bei der Dekomposition werden die rechten Seiten der FDs aufgespalten, sodass jede übrig bleibende FD die Form alpha -> B hat, also nur ein Attribut auf der rechten Seite, bei beliebiger linker Seite. .... Bei der Linksreduktion werden werden keine FDs hinzugefügt oder entfernt. .... Es wird überprüft, ob sich der rechte Teil, also B, auch dann herleiten lässt, wenn die linke Seite, alpha, weniger Attribute enthält. .... Dazu versucht man, ein Attribut der linken Seite zu entfernen, und überprüft dann, ob B immer noch in der Hülle der neuen, gekürzen linken Seite enthalten ist. .... Wenn ja, war dieses Attribut redundant und darf entfernt werden. Es werden in diesem Schritt also weder neue FDs eingefügt, noch bestehende FDs entfernt. .... Bei der Rechtsreduktion wird überprüft, ob eine FD selbst redundant ist, also, ob die Hülle der restlichen FDs äquivalent bleibt, wenn diese FD entfernt wird. .... Wenn ja, war sie redundant und kann entfernt werden. Es werden in diesem Schritt also, wenn es möglich ist, ganze FDs entfernt, aber keine einzelnen Attribute. .... Und am Schluss werden mittels Vereinigungsregel alle rechten Seiten, die die gleichen linken Seiten haben, zusammengefasst. 
(36) Bei welchen Mengen von FDs im Bild kann es sich um KÜs handeln?;Menge 1 ist eine Kanonische Überdeckung.;Menge 2 ist eine Kanonische Überdeckung.;Menge 3 ist eine Kanonische Überdeckung.;Menge 4 ist eine Kanonische Überdeckung.;Keine der genannten Antworten.;1;36.png;1. Richtig, das ist eine Kanonische Überdeckung. Eine erneute einfache Berechnung der KÜ zeigt, dass sich nichts mehr vereinfachen oder streichen lässt. .... 2. Falsch. Bei der ersten Menge wurde die Vereinigung nicht richtig durchgeführt, da es zwei FDs gibt, die die gleiche linke Seite haben. .... 3. Falsch. Hier gibt es auf den ersten Blick noch Redundanzen durch AB?C, A?C und B?C . Bei der Linksreduktion würden A?C und B?C erhalten bleiben, aber AB?C könnte man noch kürzen, sogar auf zwei Arten. Man kann A kürzen, weil C dann immer noch in der Hülle von B enthalten ist, oder B, weil C dann immer noch in der Hülle von A enthalten ist. Hier wurde also die Linksreduktion nicht vollständig durchgeführt. .... 4. Falsch. Hier wurde eine Dekomposition durchgeführt, alle rechten Seiten enthalten nur ein Attribut, eine Linksreduktion, keine der linken Seiten kann noch irgendwie gekürzt werden, aber die Rechtsreduktion wurde noch nicht durchgeführt, da es noch Redundanzen gibt. Die ersten drei Regeln, A -> B, B -> C und C -> D können nicht vereinfacht werden, aber die vierte Regel ist redundant, denn, wenn man diese Regel streichen würde, bleibt die rechte Seite, also D, immer noch in der Hülle der linken Seite, A, erhalten. 
(37) Berechne eine Kanonische Überdeckung zum Bild. Welche Schritte sind in einer Linksreduktion erlaubt?;Aus AC -> E kann man AC -> A machen.;Aus AC -> E kann man A -> E machen.;CD -> E kann man gar nicht vereinfachen.;Aus CD -> E kann man C -> E machen.;Keine der genannten Antworten.;2;37.png;Nur Antwort zwei stimmt. Um eine Linksreduktion durchzuführen, versuchen wir, eines der Attribute auf der linken Seite der FD zu streichen, und überprüfen dann, ob die rechte Seite immer noch in der Hülle der Attribute der verbliebenen linken Seite enthalten ist. .... ACHTUNG: Zur Berechnung der Hülle nimmt man immer die alten FDs, vom Anfang oder vom jeweils vorigen Schritt, aber nicht nicht die, die man gerade ändern möchte. .... Formal: Sei eine FD: alpha -> B . Dann finde die Hülle AttrHülle(F, alpha - A) . Und schau, ob die rechte Seite in dieser Hülle enthalten ist. B e  AttrHülle(F, alpha - A) . .... Wenn ja, ist die Kürzung OK, und die FD wird in ihrer neuen Form mit gestrichenem Attribut Teil der Menge. Wenn nein, ist die Kürzung verboten, da sonst Information verloren geht. .... Antwort 1 macht gar keinen Sinn, das ist keine Linksreduktion. Antwort 2 ist richtig. Man muss die Hülle der neuen linken Seite berechnen, in diesem Fall A, und die ist AttrHülle(F, A) = ABDCE, Attribut E ist also enthalten. Antwort 3 ist falsch, man kann CD -> E ebenfalls vereinfachen. Antwort 4 ist falsch, es ist genau die andere erlaubt, also D -> E, aber nicht C? E. Wir berechnen ebenfalls wieder die Hülle der neuen linken Seite, und überprüfen, ob die rechte Seite darin enthalten ist oder nicht. Wenn man D streicht, braucht man die Hülle von C, und die ist AttrHülle(F, C) = C. Wenn man C streicht, braucht man die Hülle von D, und die ist AttrHülle(F, D) = DCE. .... Das Attribut E ist in der Hülle von D, aber nicht in der von C, enthalten, also darf man nur C streichen und erhält D -> E.
(38) Welche Aussagen zur Rechtsreduktion im Bild sind richtig?;A -> B kann gestrichen werden.;Die Rechtsreduktion wurde bereits durchgeführt, man kann nichts mehr machen.;A -> E kann gestrichen werden.;A -> D kann gestrichen werden.;Keine der genannten Antworten.;3;38.png;Bei der Rechtsreduktion versucht man, jeweils die ganze FD zu streichen, und überprüft dann, ob die rechte Seite immer noch in der Hülle der linken Seite enthalten ist, wenn man diese Regel streicht. .... Antwort zwei ist falsch, man kann noch etwas machen, und zwar: .... Wenn man A -> B streichen möchte, muss man die Hülle von A ohne diese Regel berechnen, und die ist AttrHülle(F', A) = ADEC. Anders gesagt, man kann B nicht mehr von A ableiten. B ist nicht enthalten, also ist die Streichung verboten. .... Man hätte auch bereits sehen können, dass B nur hier auf der rechten Seite vorkommt, es kann also keine andere Möglichkeit geben, um B herzuleiten. .... Wenn man A -> E streichen möchte, muss man die Hülle von A ohne diese Regel berechnen, und die ist AttrHülle(F', A) = ABDEC, also in diesem Fall sogar das komplette Schema. B ist enthalten, also ist die Streichung OK. .... Für A -> D gilt das gleiche wie für A -> B. .... Somit ist A -> E die einzige Operation, die man hier durchführen darf.
(39) Welche Aussagen zu Schlüsseln sind richtig?;Ein Schlüssel bestimmt das ganze Schema.;Jeder Superschlüssel ist auch ein Schlüssel.;Jeder Schlüssel muss minimal sein.;Ein Schlüssel ist minimal, wenn er aus genau einem Attribut besteht.;Keine der genannten Antworten.;13;;Ja, ein Schlüssel bestimmt alle Attribute des Schemas. .... Nein, es ist anders herum, jeder Schlüssel ist auch ein Superschlüssel, aber nicht umgekehrt. .... Ja, ein Schlüssel muss minimal sein, sonst ist er nämlich ein Superschlüssel und kein Schlüssel. Minimal heißt aber, dass sich kein Attribut mehr entfernen lässt, wobei der gekürzte Schlüssel dann immer noch das komplette Schema bestimmt. Alle Attribute, die nicht auf der rechten Seite vorkommen, müssen Teil des Schlüssels sein, da sie sonst nie Teil einer Hülle sein können. .... Um einen Schlüssel zu bestimmen, kann man erst einen Trivialen Superschlüssel bestimmen, der aus dem ganzen Schema besteht, und dann Attribute kürzen, bis sich nichts mehr kürzen lässt.
(40) Welche Aussagen über mögliche Schlüssel dieses Schemas sind richtig?;AE ist ein Superschlüssel.;D ist ein Schlüssel.;AD ist ein Schlüssel.;Dieses Schema hat keine Schlüssel.;Keine der genannten Antworten.;12;40.png;Ja, AE ist ein Superschlüssel, weil die Hülle von AE das ganze Schema ist. Über AE -> B kommt B dazu, mit AB -> DE bekommt man DE, und mit D -> ABC schlussendlich auch noch C. .... Ja, D ist ein Schlüssel, D bestimmt das ganze Schema, über D -> ABC bekommt man ABCD, und mit AB -> DE auch noch E. Außerdem muss D minimal sein, da gibt es nichts mehr, was man kürzen könnte. .... Nein, AD kann kein Schlüssel mehr sein, weil D ja bereits ein Schlüssel war, und AD somit nicht mehr minimal sein kann, man kann noch das A streichen. .... Antwort vier macht keinen Sinn, jedes Schema muss einen Schlüssel haben, jedes Schema hat zumindest einen offensichtlichen trivialen Superschlüssel, nämlich das ganze Schema selbst, und dann kann man entweder etwas kürzen, oder nicht, aber man erhält auf jeden Fall einen Schlüssel.
(41) Welche Attribute bilden den zweiten Schlüssel, wenn CD bereits bekannt ist?;A.;B.;C.;D.;E.;13;41.png;Es gibt genau zwei Schlüssel in diesem Schema, nämlich CD und AC. .... Berechnung: Wenn man einen Schlüssel bereits kennt, kann man überprüfen, ob sich ein Teil durch einen anderen ersetzen lässt. Kommt ein Attribut eines Schlüssels irgendwo auf der rechten Seite vor, dann kann man dieses Attribut auch durch die linke Seite dieser Regel ausdrücken. .... In diesem Beispiel ist der Schlüssel CD schon bekannt. Überprüfe, ob man C durch etwas Anderes ersetzen kann. Nein, weil es nur auf der linken Seite vorkommt. Überprüfe, ob man D durch etwas Anderes ersetzen kann. Ja, es gilt nämlich AE -> D, also kann man D durch AE ersetzen. .... Unser nächster Schlüsselkandidat ist somit AEC, allerdings wissen wir noch nicht, ob er auch minimal ist, daher müssen wir überprüfen, ob sich etwas streichen lässt, und danach immer noch das komplette Schema bestimmt. .... C lässt sich sicher nicht streichen, weil es nirgendwo auf der rechten Seite vorkommt. .... Versuche es mit A, bleibt CE, die Hülle von CE ist AttrHülle(FCES) = CE, also lässt sich nicht mehr das ganze Schema bestimmen. .... Versuche es mit E, bleibt AC, die Hülle von AC ist AttrHülle(F,AC) = ACBED, also das komplette Schema, somit ist AC der zweite Schlüssel. .... Da C immer Teil des Schlüssels sein muss, weil es nicht auf der rechten Seite vorkommt, bleiben nur mehr vier mögliche Kombinationen von zwei Attributen, und eine davon war vorgegeben, man könnte also auch einfach die anderen drei überprüfen, aber dann übt man nicht, wie man Schlüssel aus bestehenden Schlüsseln berechnet.
(42) Welche Eigenschaften gelten für ein Schema in dritter Normalform 3NF?;In jeder Spalte darf es pro Zeile nur genau einen Wert geben.;In 3NF kann es nur zu Update-Anomalien kommen.;In 3NF können keine Anomalien auftreten.;In jeder Relation wird nur genau ein Konzept gespeichert.;Keine der genannten Antworten.;14;;Antwort eins stammt aus der Definition der ersten Normalform, die Werte müssen atomar sein, es darf keine Listen von Werten geben. .... Antworten zwei und drei stimmen leider nicht, es kann auch in der dritten Normalform noch zu Anomalien kommen, erst die Boyce-Codd-Normalform stellt sicher, dass es keine Anomalien mehr gibt. .... Antwort vier stammt aus der Definition der zweiten Normalform, das kann man durch eine sinnvolle Aufteilung der Attribute auf mehrere Tabellen sicherstellen.
(43) In der dritten Normalform muss jede FD eines Schemas mindestens eine welcher Eigenschaften erfüllen? [Es haben dabei alle Funktionalen Abhängigkeiten die Form alpha -> B].;Die linke Seite 'alpha' der FD ist in der rechten Seite 'B' enthalten, sodass die FD trivial ist.;Die linke Seite 'alpha' ist ein Schlüssel des Schemas.;Die rechte Seite 'B' ist in einem Superschlüssel des Schemas enthalten.;Die rechte Seite 'B' ist in einem Schlüssel des Schemas enthalten.;Keine der genannten Antworten.;4;;Antworten eins, zwei und drei sind falsch. .... Antwort eins ist genau umgekehrt. Es stimmt, dass triviale FDs immer in 3NF sind, aber dafür muss die rechte Seite in der linken Seite enthalten sein, sodass die FD die Hülle der linken Seite nicht erweitert. .... Bei Antwort zwei ist die Bedingung zu hart, es genügt, wenn alpha ein Superschlüssel des Schemas ist, es muss nicht umbedingt ein Schlüssel sein. .... Antwort drei ist dafür zu allgemein, die rechte Seite muss in einem Schlüssel enthalten sein, wie es in Antwort vier steht.
(44) Welche Aussagen über Normalformen sind richtig?;Jedes Schema in dritter Normalform 3NF ist automatisch auch in Boyce-Codd-Normalform BCNF.;Jedes Schema in Boyce-Codd-Normalform BCNF ist automatisch auch in dritter Normalform 3NF.;In BCNF gilt die Regel, dass die rechte Seite in einem Schlüssel enthalten sein muss, nicht.;In BCNF gilt die Regel, dass die linke Seite ein Superschlüssel sein muss, nicht.;Keine der genannten Antworten.;23;;Die Zusammenhänge zwischen den Normalformen sind so wie in Antwort 2 beschrieben: Jedes Schema in BCNF ist automatisch auch in 3NF, aber nicht umgekehrt. .... Antwort drei ist genau das, wie der Unterschied zwischen 3NF und BCNF definiert ist: Die dritte Regel für Funktionale Abhängigkeiten, dass die Normalform vorliegt, wenn die rechte Seite Teil eines Schlüssels ist, gilt nur in der 3NF, aber nicht der BCNF.
(45) Welche Schemata im Bild sind in dritter Normalform?;Das erste Schema ist in dritter Normalform.;Das zweite Schema ist in dritter Normalform.;Das dritte Schema ist in dritter Normalform.;Das vierte Schema ist in dritter Normalform.;Keine der genannten Antworten.;14;45.png;Das erste Schema ist in 3NF. .... Die erste Bedingung, dass die Funktionalen Abhängigkeiten trivial sind, ist in der ersten FD erfüllt. .... Die zweite Bedingung, dass die linke Seite ein Superschlüssel ist, stimmt für alle Funktionalen Abhängigkeiten, somit gilt die 3NF bereits. .... Der Vollständigkeit halber überprüfen wir noch die dritte Regel, dass die rechte Seite in einem Schlüssel enthalten sein muss, und das ist bei der zweiten Funktionale Abhängigkeit der Fall. .... Das zweite Schema ist in nicht 3NF. .... Die erste Bedingung, dass die FD trivial ist, stimmt bei der ersten FD. .... Die zweite Bedingung, dass die linke Seite ein Superschlüssel ist, stimmt bei FD eins, zwei und drei. .... Die dritte Bedingung, dass die rechte Seite in einem Schlüssel enthalten ist, stimmt bei eins. .... Nummer vier erfüllt keine der drei Bedingungen, also ist dieses Schema nicht in 3NF. .... Das dritte Schema ist nicht in 3NF. .... Die erste Bedingung, dass die FD trivial ist, stimmt nirgends. .... Die zweite Bedingung, dass die linke Seite ein Superschlüssel ist, stimmt nur in der dritten FD. .... Die dritte Bedingung, dass die rechts Seite in einem Schlüssel enthalten ist, stimmt nirgends. .... Also gibt es FDs, die keine der drei Bedingungen erfüllen, und somit ist das Schema nicht in 3NF. .... Das vierte Schema ist wieder in 3NF. .... Die erste Bedingung, dass die FD trivial ist, ist nirgendwo erfüllt. .... Die zweite Bedingung, dass die linke Seite ein Superschlüssel ist, gilt für die erste und zweite FD, die dritte aber nicht. .... Die dritte Bedingung, dass die rechte Seite in einem Schlüssel enthalten ist, gilt für die dritte DF. .... Somit erfüllen alle Funktionalen Abhängigkeiten mindestens eine der drei Bedingungen, und somit ist das Schema in 3NF.
(46) Welche Schemata im Bild sind in Boyce-Codd Normalform?;Das erste Schema ist in Boyce-Codd Normalform.;Das zweite Schema ist in Boyce-Codd Normalform.;Das dritte Schema ist in Boyce-Codd Normalform.;Das vierte ist in Boyce-Codd Normalform.;Keine der genannten Antworten.;1;46.png;Wir gehen genau so vor wie bei der 3NF, nur mit dem Unterschied, dass die dritte Regel in der BCNF nicht gilt, bei der die rechte Seite Teil eines Schlüssels sein muss. ... Wir wenden immer nur die erste und zweite Regel an: Entweder ist die FD trivial, oder die linke Seite ein Superschlüssel. .... Das erste Schema ist somit in BCNF, das zweite nicht, das dritte auch nicht, und die vierte ebenfalls nicht.
(47) Welche Aussagen über Abhängigkeitstreue und Verlustlosigkeit sind wahr?;Verlustlosigkeit heißt: Bei der Zerlegung eines Schemas müssen die Schlüssel gleich bleiben.;Abhängigkeitstreue heißt: Bei der Zerlegung eines Schemas müssen alle FDs erhalten bleiben.;Verlustlosigkeit heißt: Beim Join der Teil-Schemata muss das originale Schema wiederherstellbar sein.;Eine Zerlegung eines Schemas in 3NF ist immer abhängigkeitstreu.;Keine der genannten Antworten.;234;;Schlüssel können sich ändern. Das sind genau die Definitionen von Abhängigkeitstreue und Verlustlosigkeit. .... Und Zerlegungen in 3NF sind immer abhängigkeitstreu, Zerlegungen in BCNF aber nicht.
(48) Welche Aussagen über Abhängigkeitstreue und Verlustlosigkeit sind wahr?;Man kann jedes Schema durch Zerlegung in 3NF bringen.;Eine Zerlegung eines Schemas in 3NF ist immer verlustlos.;Am Ende einer Zerlegung gibt es so viele Teil-Schemata, wie es vorher Schlüssel gibt.;Eine Zerlegung eines Schemas in BCNF ist immer verlustlos.;Keine der genannten Antworten.;124;;Jedes Schema sollte sich in 3NF zerlegen lassen. Solch eine Zerlegung ist immer verlustlos. .... Darüber, wie viele Teil-Schemata es am Ende gibt, lässt sich so nichts sagen. Es können mehr werden, weil für jeden Schlüssel, der nicht in einem der Teil-Schemata enthalten ist, eine neue erstellt werden muss, andererseits aber redundante Schemata, die bereist in anderen enthalten sind, gekürzt werden können. .... Eine Zerlegung in BCNF muss auch immer verlustlos sein, nur Abhängigkeitstreue ist nicht garantiert.
(49) Welche Aussagen zum Synthesealgorithmus sind wahr?;Zuerst berechnet man die Kanonische Überdeckung.;Für jeden Schlüssel wird ein neues Teil-Schema erstellt.;Für jede FD, die noch nicht in Teil-Schemata existiert, wird ein neues erstellt.;Redundante Schemata werden eliminiert.;Keine der genannten Antworten.;14;;Man fängt mit der KÜ an, dann wird für jede Funktionale Abhängigkeit ein neues Teil-Schema erstellt, das aus allen Attributen der FD besteht. .... Zusätzlich muss man sicherstellen, dass mindestens ein Schlüssel in einem der neuen Schemata enthalten ist, andernfalls können die Schemata nicht wieder korrekt zusammengejoint werden. Am Schluss werden redundante Schemata gestrichen.
(50) Ist die Zerlegung eines Schemas im Bild in dritte Normalform korrekt?;Ja, die Zerlegung ist korrekt.;Nein, diese Zerlegung ist nicht abhängigkeitstreu.;Nein, diese Zerlegung ist nicht verlustlos.;Nein, diese Zerlegung enthält noch zu viele redundante Schemata.;Keine der genannten Antworten.;3;50.png;Nein, das ist nicht korrekt, da fehlt der Schritt, dass ein weiteres Teil-Schema erzeugt werden muss, da keiner der Schlüssel in einem der Teile enthalten sind. Somit ist es nicht möglich, die Teil-Schemata wieder zu einem ganzen zusammenzujoinen, die Aufteilung ist also nicht verlustfrei.
(51) Ist die Zerlegung eines Schemas im Bild in dritte Normalform korrekt?;Ja, die Zerlegung ist korrekt.;Nein, diese Zerlegung ist nicht abhängigkeitstreu.;Nein, diese Zerlegung ist nicht verlustlos.;Nein, diese Zerlegung enthält noch zu viele redundante Schemata.;Keine der genannten Antworten.;1;51.png;Ja, hier stimmt die Zerlegung.
(52) Welche Aussagen über Dekomposition eines Schemas in BCNF sind wahr?;Verlustlosigkeit ist in BCNF garantiert.;Abhängigkeitstreue ist in BCNF garantiert.;Jede FD, die die BCNF verletzt, muss aufgespalten werden.;Man bildet zwei neue Teilschemata aus den Attributen der aufgespaltenen FD.;Keine der genannten Antworten.;13;;Ja, in BCNF gilt Verlustlosigkeit, aber nicht Abhängigkeitstreue. Der Algorithmus geht so vor, dass immer eine Funktionale Abhängigkeit aufgespalten wird, so lange, bis es keine FD mehr gibt, die die BCNF verletzt.
(53) Ist die Zerlegung eines Schemas im Bild in BCNF korrekt?;Ja, die Zerlegung ist korrekt.;Nein, die Aufteilung der Attribute des ersten Schemas R1 stimmt nicht.;Nein, die Aufteilung der Attribute des zweiten Schemas R2 stimmt nicht.;Nein, die Schemata müssen noch zusammengefasst werden.;Keine der genannten Antworten.;1;53.png;Ja, hier stimmt alles, das Beispiel ist richtig.
(54) Ist die Zerlegung eines Schemas im Bild in BCNF korrekt?;Ja, die Zerlegung ist korrekt.;Nein, die Aufteilung der Attribute des ersten Schemas R1 stimmt nicht.;Nein, die Aufteilung der Attribute des zweiten Schemas R2 stimmt nicht.;Nein, die Schemata müssen noch zusammengefasst werden.;Keine der genannten Antworten.;3;54.png;Nein, die Aufteilung stimmt nicht. Wenn eine Funktionale Abhängigkeit in zwei aufgeteilt wird, bekommt eine davon alle Attribute der FD, und die zweite bekommt alle Attribute des Schemas außer denen, die nur auf der rechten Seite der FD vorkommen. Die zweite müsste also alle Attribute außer das B haben.
(55) Welche Antworten über Null-Werte in SQL sind richtig?;Unknown AND True ergibt True.;Unknown OR True ergibt True.;Unknown OR Unknown ergibt True.;Unknown AND Unknown ergibt True.;Keine der genannten Antworten.;2;;Jedes Oder mit einem True muss True ergeben, sonst bleibt immer der Unknown Wert erhalten.
(56) Welche der Aussagen sind wahr?;Duplikate in einem Ergebnis werden automatisch eliminiert.;Der RANGE Operator kann verwendet werden, um Werte in einem bestimmten Bereich zu erhalten.;Ein PRIMARY KEY kann auch aus mehreren Spalten bestehen.;Es kann in einer Tabelle mehrere FOREIGN KEYs geben.;Keine der genannten Antworten.;34;;Duplikate werden nicht automatisch eliminiert, das wäre zu teuer, das macht das System nur, wenn man das DISTINCT Keyword verwendet. .... Der Bereichs-Operator heißt nicht RANGE sondern BETWEEN. .... Ja, der PRIMARY KEY kann beliebig viele Spalten umfassen, dann muss er extra definiert werden, sonst kann man ihn auch einfach bei der Definition der Spalte dazuschreiben. .... Ja, es gibt auch mehrere FOREIGN KEYS, andernfalls könnte man ja nicht mehrere Tabellen verlinken.
(57) Welche Aussagen zum WAL-Prinzip sind richtig?;Wenn eine Transaktion committen will, müssen davor alle ihre Log-Einträge geschrieben worden sein.;Wenn eine Transaktion committen will, müssen davor alle ihre Speicher-Seiten geschrieben worden sein.;Wenn eine Seite ausgelagert wird, müssen davor alle Log-Einträge, die sie betreffen, geschrieben worden sein.;Die Reihenfolge der Einträge muss immer erhalten bleiben.;Keine der genannten Antworten.;134;;WAL steht für Write-Ahead-Log und betrifft also nur das Log, keine Speicherseiten der Tranksaktionen. .... Antworten eins, drei und vier sind genau die, über die das Write-Ahead-Log definiert war. .... Antwort zwei kann nicht stimmen, da es beim Write-Ahead-Log nur um die Log-Einträge geht, wie der Name schon zeigt, bei der Frage, was mit Speicherseiten geschieht, kann man hingegen Steal vs. Not Steal und Force vs. Not Force zu Rate ziehen.
(58) Es gelte Logische Protokollierung. Welche dieser Log-Einträge im Bild sind korrekt? [Der Inhalt des Hintergrundspeichers wurde zur Vereinfachung weggelassen.];Der Log-Eintrag Nummer 1 in Zeile 1 ist korrekt.;Der Log-Eintrag Nummer 2 in Zeile 2 ist korrekt.;Der Log-Eintrag Nummer 3 in Zeile 3 ist korrekt.;Der Log-Eintrag Nummer 4 in Zeile 4 ist korrekt.;Keine der genannten Antworten.;23;58.png;Es gibt folgende Probleme in der Grafik: .... Zeile 1 ist falsch, am Anfang gibt es noch nichts zum Umkehren, das muss also sicher ein Eintrag mit eckigen Klammern sein. .... Zeile 2 ist in Ordnung, die Transaktion T1 macht gleich ein abort, das Begin of Transaktion wird rückgängig gemacht, das Recovery für T1 ist fertig. .... Zeile 3 ist in Ordnung. .... Zeile 4 stimmt nicht, da versucht der Log-Eintrag auf zwei verschiedene Speicherseiten A und B zuzugreifen. .... Zeile 5 stimmt nicht, da ist die Nummer des Log-Eintrags doppelt vorhanden. .... Zeile 6 ist in Ordnung. .... Zeile 7 stimmt nicht, die letzte Zahl im Log-Eintrag müsste auf den vorigen Eintrag derselben Transaktion verweisen, also für T1 Nummer vier statt fünf. .... Zeile 8 ist in Ordnung. .... Zeile 9 ist in Ordnung. .... Zeile 10 stimmt nicht, dort steht eine physische Protokollierung, es soll aber immer logische sein. .... Zeile 11 ist in Ordnung. .... Zeile 12 ist in Ordnung. .... Zeile 13 ist in Ordnung. .... Zeile 14 ist in Ordnung. .... Zeile 15 stimmt nicht, dort wurde die Redo anstatt der Undo-Operation genommen. .... Zeile 16 stimmt nicht, dort wurden die Werte für den vorigen Log-Eintrag der Transaktion PrevLSN und der Wert für den nächsten Log-Eintrag, den man bearbeiten muss, UndoNextLSN, vertauscht. .... Somit stimmen Zeilen zwei, drei, sechs, acht, neun, elf, zwölf, dreizehn und vierzehn. .... Zeilen eins, vier, fünf, sieben, zehn, fünfzehn und sechzehn enthalten Fehler.
(59) Es gelte Logische Protokollierung. Welche dieser Log-Einträge im Bild sind korrekt? [Der Inhalt des Hintergrundspeichers wurde zur Vereinfachung weggelassen.];Der Log-Eintrag Nummer 4 in Zeile 5 ist korrekt.;Der Log-Eintrag Nummer 5 in Zeile 6 ist korrekt.;Der Log-Eintrag Nummer 6 in Zeile 7 ist korrekt.;Der Log-Eintrag Nummer 7 in Zeile 8 ist korrekt.;Keine der genannten Antworten.;24;59.png;Erklärung siehe vorige Frage.
(60) Es gelte Logische Protokollierung. Welche dieser Log-Einträge im Bild sind korrekt? [Der Inhalt des Hintergrundspeichers wurde zur Vereinfachung weggelassen.];Der Log-Eintrag Nummer 9 in Zeile 10 ist korrekt.;Der Log-Eintrag Nummer 13 in Zeile 14 ist korrekt.;Der Log-Eintrag Nummer 14 in Zeile 15 ist korrekt.;Der Log-Eintrag Nummer 15 in Zeile 16 ist korrekt.;Keine der genannten Antworten.;2;60.png;Erklärung siehe vorige Frage.
(61) Wenn ein DBMS eine Strategie von STEAL und FORCE einsetzt, was muss beim Recovery ausgeführt werden?;Es muss ein Redo ausgeführt werden.;Es muss kein Redo ausgeführt werden.;Es muss ein Undo ausgeführt werden.;Es muss kein Undo ausgeführt werden.;Keine der genannten Antworten.;23;;Steal heißt, alle Seiten dürfen ausgelagert sein, somit kann es also auch sein, dass Seiten von Transaktionen, die nachher abgebrochen werden, bereits geschrieben sind, deswegen muss ein Undo gemacht werden. .... Force heißt, dass alle Seiten am Ende einer erfolgreichen Transaktion geschrieben sein müssen, es können also keine Daten verloren gehen, ein Redo ist nicht notwendig. Entweder eine Transaktion ist erfolgreich abgeschlossen, dann sind ihre Daten sicher im Hintergrundspeicher, oder sie wird abgebrochen, dann ist es egal, die Daten gehen einfach verloren und müssen nicht wiederhergestellt werden. .... Somit ist ein Undo notwendig, ein Redo aber nicht.
(62) Wenn ein DBMS eine Strategie von NOT STEAL und FORCE einsetzt, was muss beim Recovery ausgeführt werden?;Es muss ein Redo ausgeführt werden.;Es muss kein Redo ausgeführt werden.;Es muss ein Undo ausgeführt werden.;Es muss kein Undo ausgeführt werden.;Keine der genannten Antworten.;24;;Not Steal bedeutet, dass keine Seiten einer Transaktion ausgelagert worden sind, es kann also nicht vorkommen, dass Seiten einer Transaktion, die nachher abgebrochen werden muss, schon geschrieben sind. Also braucht man kein Undo. .... Force bedeutet, dass beim Abschluss einer Transaktion alle Speicherseiten geschrieben sind, es kann also nicht vorkommen, dass Seiten einer abgeschlossenen Transaktion noch nicht geschrieben sind. Also braucht man kein Redo. .... Also ergibt sich in dieser Kombination, dass man weder Redo noch Undo braucht.
(63) Welche Eigenschaften erwartet man sich von einem DBMS?;Atomarität (Atomicity).;Konsistenz (Consistency).;Unabhängigkeit (Isolation).;Langlebigkeit (Durability).;Keine der genannten Antworten.;1234;;Ein DBMS muss ACID einhalten. Dazu gehören Atomicity, also Transaktionen schließen entweder erfolgreich ab, und alle Änderungen finden sich in der Datenbasis, oder gar nicht, dann haben sie gar keinen Einfluss auf die Datenbasis, es darf keine Situation vorkommen, sodass ein Teil-Ergebnis in der Datenbank steht. .... Consistency, also die Daten müssen immer vor und nach einer Transaktion in einem konsistenten Zustand sein. .... Isolation, also nebenläufige Transaktionen dürfen sich gegenseitig nicht beeinflussen. .... Und Durability, sobald eine Transaktion abgeschlossen ist, darf ihr Ergebnis nicht verloren gehen. 
(64) Welche Art von Konflikt kann ein Lost Update hervorrufen?;Lese-Lese Konflikte (R-R).;Lese-Schreib Konflikte (R-W).;Schreib-Lese Konflikte (W-R).;Schreib-Schreib-Konflikte (W-W).;Keine der genannten Antworten.;4;;Lese-Lese Konflikte gibt es nicht, es muss mindestens ein Schreibzugriff für einen Konflikt erfolgen. .... Wenn eine Transaktion schreibt, und dann eine andere Transaktion schreibt, kann es passieren, dass die zweite den Wert des ersten überschreibt. Ein Lost Update kann also nur bei Schreib-Schreib-Konflikten auftreten. .... Zusätzlich gibt es noch Dirty Read, die durch Schreib-Lese-Konflikte entstehen können. .... Und schließlich noch Unrepeatable Read, und Phantomprobleme, die dadurch entstehen können, dass eine Transaktion erst einen Wert liest, der dann von einer anderen Transaktion überschrieben wird, woduch ein erneutes Lesen einen anderen Wert ergeben kann. Phantomprobleme funktionieren ähnlich, nur dass es darum geht, dass zusätzliche Werte eingefügt werden, anstatt bestehende zu ändern.
(65) Welche Probleme kann ein Schreib-Lese-Konflikt hervorrufen?;Ein Schreib-Lese-Konflikt kann zu Lost Updates führen.;Ein Schreib-Lese-Konflikt kann zu einem Dirty Read führen.;Ein Schreib-Lese-Konflikt kann zu Unrepeatable Read führen.;Ein Schreib-Lese-Konflikt kann zu gar keinem Konflikt führen.;Keine der genannten Antworten.;2;;Wenn ein Wert erst geschrieben und dann von einer anderen Transaktion gelesen wird, kann es passieren, dass das Lesen einen falschen Wert liefert. Transaktion A startet, und schreibt einen Wert, den Transaktion B liest, so weit so gut, aber wenn Transaktion A abgebrochen wird, hätte Transaktion B einen Wert gelesen, der eigentlich gar nicht in der Datenbank steht. Das nennt man einen Dirty Read.
(66) Betrachte den Serialisierbarkeitsgraphen im Bild. Welche Aussagen können wir über diese erfolgreich abschließende Transaktion machen?;Es existiert eine rücksetzbare Historie.;Es existiert eine strikte Historie.;Es existiert eine serialisierbare Historie.;Es existiert eine konfliktserialisierbare Historie.;Keine der genannten Antworten.;34;66.png;Eine Historie ist dann konfliktserialisierbar, wenn ihr Serialisierbarkeitsgraph keine Zyklen enthält. .... Wenn keine Transaktion abbricht, dann ist eine konfliktserialisierbare Historie automatisch auch serialisierbar, aber nicht umgekehrt. .... Sonst können wir keine Aussagen allein über den Graphen machen.
(67) Welche Aussagen über Deadlocks sind für das Bild richtig?;In diesen Transaktionen wird ein Deadlock durch Preclaiming ausgeschlossen.;In diesen Transaktionen sind keine Maßnahmen notwendig, da es ohnehin nicht zu einem Deadlock kommen kann.;Ein Deadlock kann hier mittels Wound-Wait Strategie vermieden werden.;Ein Deadlock kann hier mittels Wait-Die Strategie vermieden werden.;Keine der genannten Antworten.;34;67.png;Preclaiming heißt, dass die Transaktion erst beginnen darf, wenn sie alle benötigten Sperren hält. Das ist hier eindeutig nicht der Fall. .... Weil T1 und T2 jeweils gegenseitig überkeuzte Sperren haben wollen, kann es sehr wohl zu Deadlocks kommen. .... Sowohl die Wound-Wait Strategie als auch die Wait-die Strategie bieten sich hier an, um Deadlocks zu vermeiden. .... In Schritt 7 will T1 eine Sperre haben, die T2 schon hält, und ist dabei die ältere Transaktion. .... Wenn die Wound-Wait Strategie eingesetzt werden würde, würde T2 in Schritt 8 abgebrochen werden, und T1 zuerst fertig laufen, weil T1 die ältere Transaktion ist. .... Wenn die Wait-Die Strategie eingesetzt werden würde, würde zuerst T1 auf die Freigabe der Sperre warten, und T2 weiterlaufen. .... Dann möchte T2 die Sperre von T1 haben, was aber abgelehnt wird, weil T2 die jüngere Transaktion ist, also wäre in der Situation die Transaktion, die die Sperre haben will, die jüngere, und wird also abgebrochen, und T1 bekommt ihre Sperre und läuft fertig durch.
(68) Was sind die Eigenschaften des strengen Zwei-Phasen-Sperrprotokolls (S2PL)?;Die Anzahl der Sperren ist wachsend bis zum EOT.;S2PL garantieret keine Konfliktserialisierbarkeit.;S2PL garantiert Rücksetzbarkeit.;S2PL lässt nur strikte Historien zu.;Keine der genannten Antworten.;134;;Beim S2PL sind keine Freigaben von Sperren vor Transaktionsende erlaubt. Damit erreicht man Rücksetzbarkeit. Da eine Sperre bis zum Ender der Transaktion (EOT) bleibt, bedeutet es, dass nur strikte Historien möglich sind, da auf ein von einer Transaktion geschriebenes Datum, andere Transaktionen erst nach deren Beendigung zugreifen dürfen. Auch das gewöhnliche Zwei-Sperren-Protokoll (2PL) garantiert Konfliktserialisierbarkeit. Weil jedes S2PL ein 2PL ist, garantiert auch S2PL Konfliktserialisierbarkeit. 
(69) Welche Aussagen über das 2-Phasen-Sperrprotokoll sind wahr?;Nach der ersten Freigabe darf die Transaktion keine weiteren Sperren anfordern;Vor einer Leseoperation muss ein Objekt nicht gesperrt werden.;Am Ende (EOT) werden alle nicht freigegebenen Ressourcen gelöscht.;Wenn eine Sperre nicht gewährt wird, so wird die Transaktion zurückgesetzt.;Keine der genannten Antworten.;1;;Nachdem eine Transaktion eine Sperre freigegeben hat darf sie keine weiteren Sperren mehr anfordern. Eine Folgerung dieser Regel von 2PL ist, dass jede Transaktion eine Wachstumsphase besitzt.  Beim 2PL muss jedes von einer Transaktion benützte Objekt vor Verwendung entsprechend gesperrt werden. Am Transaktionsende (EOT) müssen alle Sperren freigegeben worden sein. Sperren werden nach der Kompatibilitätsmatrix gewährt. Kann eine Sperre nicht gewährt werden, wartet die Transaktion bis die Sperre gewährt werden kann.
(70) Was gilt für die Kompatibilitätsmatrix des 2-Sperren-Protokolls im Bild?;Im Fall von ?4 wird die Sperre gewährt.;Im Fall von ?2 wird die Sperre gewährt.;Im Fall von ?5 wird die Sperre gewährt.;Beim aktuellen X wird keine weitere Sperre gewährt.;Keine der genannten Antworten.;124;j1-1.jpg;
(71) Was gilt für die Kompatibilitätsmatrix des 2-Sperren-Protokolls im Bild?;Im Fall von ?3 wird die Sperre gewährt.;Im Fall von ?1 wird die Sperre gewährt.;Im Fall von ?6 wird die Sperre gewährt.;Beim NL wird keine Sperre gewährt.;Keine der genannten Antworten.;2;j1-1.jpg;
(72) Welche Aussagen über das Multiple Granularity Locking (MGL) sind wahr?;MGL verwendet einheitliche Sperrgranulate.;MGL benötigt erweiterte Sperrmodi.;MGL benötigt ein erweitertes Sperrprotokoll.;Sperrmodi bei MGL sind NL, S, X, INL, IS, IX. ;Keine der genannten Antworten.;23;;Die Idee von MGL ist, mehr Flexibilität durch unterschiedliche Sperrgranulate zu ermöglichen. Das wird erreicht, indem das DBMS oder der Benutzer (die Benutzerin) die passende Granularität (Datensatz, Tabelle, Seite, Segmente, Datenbasis) auswählt. Deswegen sind erweiterte Sperrmodi und ein erweitertes Sperrprotokoll nötig.  Sperrmodi bei MGL sind:  NL Keine Sperre (No Lock), S Lesesperre (Shared lock), X Schreibsperre (eXclusive lock), IS Tiefer in der Hierarchie ist eine Lesesperre (S) beabsichtigt (Intention Shared lock),  IX Tiefer in der Hierarchie ist eine Schreibsperre (X) beabsichtigt (Intention eXcluse lock). INL ist kein Sperrmodus bei MGL.
(73) Was gilt für die Kompatibilitätsmatrix des MGLs im Bild?;Fälle ?1 bis ?3 und ?1 bis ?6 löst man genau wie beim 2-Sperren-Protokoll. ;Beim aktuellen S (Lesesperre) dürfen keine weiteren Sperren gewährt.;Beim aktuellen X (Schreibsperre) dürfen keine weiteren Sperren gewährt.;Das IS bzw. IX fordert man an, wenn man unten ein S oder X braucht.;Keine der genannten Antworten.;134;j2-1.jpg;Betrachte die Kompatibilitätsmatrix in den Folien. Das I steht für Intention, d.h. tiefer in der Hierarchie ist eine Lesesperre (S) bzw. eine Schreibsperre (X) beabsichtigt.
(74) Was gilt für die Kompatibilitätsmatrix des MGLs im Bild?;Sowohl ?4 als auch ?5 werden gewährt.;Sowohl ?9 als auch ?10 werden gewährt.;Sowohl ?14 als auch ?15 werden gewährt.;Sowohl ?19 als auch ?20 werden gewährt.;Keine der genannten Antworten.;34;j2-1.jpg;Eine S-Sperre wird beim aktuellen X oder IX nicht gewährt. Eine X-Sperre wird nur gewährt, wenn es aktuell keine Sperre gibt (NL).
(75) Was gilt für die Kompatibilitätsmatrix des MGLs im Bild?;Sowohl ?11 als auch ?16 werden gewährt.;Sowohl ?12 als auch ?17 werden gewährt.;Sowohl ?13 als auch ?18 werden gewährt.;Sowohl ?14 als auch ?19 werden gewährt.;Keine der genannten Antworten.;14;j2-1.jpg;Eine IX-Sperre wird beim aktuellen S oder X nicht gewährt. Beim aktuellen X (Schreibsperre) dürfen keine weiteren Sperren gewährt.
(76) Was gilt für den Lesezugriff bei Zeitstempel-basierter Synchronisation?;Falls TS(Ti) < writeTS(A), wird Ti zurückgesetzt.;Falls TS(Ti) < writeTS(A), darf Ti A lesen.;Fall TS(Ti) < writeTS(A), muss readTS(A) auf max(TS(Ti ), readTS(A)) gesetzt werden.;Der Fall TS(Ti) = writeTS(A) ist gleich wie TS(Ti) > writeTS(A).;Keine der genannten Antworten.;14;;Antworten 2 und 3 wären korrekt, hätten wir TS(Ti) >= writeTS(A).
(77) Was gilt für den Schreibzugriff bei Zeitstempel- basierender Synchronisation?;Beim Schreibzugriff haben wir drei verschiedene Fälle.;Falls TS(Ti ) < readTS(A), darf Ti auf A schreiben.;Falls TS(Ti ) < writeTS(A), muss writeTS(A) auf TS(Ti) gesetzt werden.;Sonst, muss man Ti zurücksetzen.;Keine der genannten Antworten.;1;;Falls TS(Ti ) < readTS(A) oder TS(Ti ) < writeTS(A), muss man Ti zurücksetzen. Sonst darf Ti auf A schreiben und writeTS(A) nimmt den Wert von TS(Ti). 
(78) Was sind Eigenschaften der Zeitstempel-basierten Synchronisation?;Es entstehen keine Deadlocks.;Sie liefert konfliktserialisierbare Historien.;Die Reihenfolge in serieller Historie entspricht Zeitstempeln.;Die Historien können rücksetzbar sein.;Keine der genannten Antworten.;123;;Historien können nicht rücksetzbar sein. Dafür gibt es drei Lösungsmöglichkeiten: Die erste ist die rücksetzbare Variante: Verzögere commit bis alle Transaktionen von denen gelesen wurde beendet sind (verwalte Liste). Die zweite ist die strikte Variante: Führe alle Schreibvorgänge atomar am Ende der Transaktion durch. Alternativ kann man, noch nicht festgeschriebene, Daten markieren und den Zugriff darauf verzögern.
(79) Wofür das 'dirty Bit' in der Zeitstempel-basierten Synchronisation?;Das Bit ist für die Erkennung von Deadlocks notwendig.;Es vermerkt, ob ein Datensatz von einer aktiven Transaktion geschrieben wurde.;Es ist für die sogenannte strikte Synchronisation nötig.;Das Bit garantiert strikte Historien.;Keine der genannten Antworten.;234;;Jede Version der Zeitstempel-basierenden Synchronisation kann Deadlocks erkennen, nicht nur die strikte Version mit dem 'dirty Bit'.
(80) Ergänze die allgemeine Syntax der Transaktionsverwaltung in SQL.;An den Stellen ?1 und ?2 stehen 'READ UNCOMMITED' und 'READ COMMITED'.;An den Stellen ?1 und ?2 stehen 'READ WRITE' und 'READ ONLY'.;An der Stelle ?3 steht 'READ LEVEL'.;An der Stelle ?4, ?5, oder ?6 steht 'REPEATABLE READ'.;Keine der genannten Antworten.;24;j4-1.jpg;SET TRANSACTION [READ WRITE | READ ONLY] [ISOLATION LEVEL { READ UNCOMMITED | READ COMMITED | REPEATABLE READ | SERIALIZABLE }]
(81) Was sind Eigenschaften der Isolationsstufen in SQL?;SERIALIZABLE ist die schwächste Stufe.;READ COMMITED ist die höchste Stufe.;REPEATABLE R.: Nur die vor Beginn der Operation committeten Sätze sind sichtbar.;READ COMMITED: Nur die erste commitete Aktion der Transaktion ist sichtbar.;Keine der genannten Antworten.;5;;READ UNCOMMITED: Schwächste Stufe. Kann nicht festgeschriebene Änderungen lesen und daher auch inkonsistente Datenbankzustände sehen. Nur für READ ONLY Transaktionen erlaubt. READ COMMITED: Jede Operation sieht nur Datensätze, die vor dem Beginn der Operation committet waren. REPEATABLE READ: Alle Operationen der Transaktion sehen nur Datensätze, die vor der ersten Aktion der Transaktion committet waren. SERIALIZABLE: Höchste Stufe. Garantiert, dass die Ausführung einer seriellen Ausführung entspricht.
(82) Was sind die möglichen Anomalien verschiedener Isolationsstufen?;1;2;3;4;Keine der genannten Antworten.;4;j4-2.jpg;
(83) Was gilt für den PL/pgSQL Trigger 'trCheckGenre' im Bild?;Falls es keinen Song in der Playlist gibt, wird der Song zur Playlist hinzugefügt;Der Trigger wird niemals durchlaufen.;Falls es Songs in der Playlist gibt, muss ein neuer Song vom selben Genre sein.;Falls es Songs in der Playlist gibt, muss ein neuer Song von verschiedenem Genre sein.;Keine der genannten Antworten.;13;j8-1.jpg;Diese Funktion stellt sicher, dass nur Songs des gleichen Genres in einer Playlist vorhanden sein dürfen. Das bedeutet, dass wenn noch kein Song in der Playlist vorhanden ist, wird der Song auf jeden Fall zur Playlist hinzugefügt. Weiters wenn Songs bereits in der Playlist vorhanden sind, muss der Song vom selben Genre, wie die Songs in der Playlist, sein. Sonst wird dieser nicht hinzugefügt und eine Exception mit dem Text Song has different genre! wird ausgeworfen.
(84) Was gilt für den PL/pgSQL Trigger 'trFl' im Bild?;trFl feuert vor dem Löschen eines Eintrags in der flug-Tabelle.;trFl feuert vor dem Einfügen eines Eintrags in der flug-Tabelle für jede Zeile.;Falls der im Feld 'nach' angebene Flughafen existiert, bleibt das Tupel gleich.;In jedem Fall muss Flughafen 'VIE' für 'nach' ausgewählt werden.;Keine der genannten Antworten.;23;j8-2.jpg;Falls der im Feld 'nach' angebene Flughafen existiert, soll das Tupel unverändert eingefügt werden. Existiert der Flughafen nicht, so soll ein neuer Wert 'nach.neu' bestimmt werden, der anstatt 'nach' im einzufügenden Tupel gesetzt wird. Der Wert für 'nach.neu' wird wie folgt bestimmt: Wenn es zumindest einen Flughafen gibt dessen name mit dem Wert von 'nach' beginnt, soll der name einer dieser Flughäfen für 'nach.neu' gewählt werden. Existiert kein solcher Flughafen, so soll 'VIE' für 'nach.neu' gewählt werden.
(85) Welche Aussagen über PL/pgSQL Funktionen als Trigger sind korrekt?;Die Funktion darf keine Argumente haben.;Die Funktion muss den Rückgabewert 'trigger' haben.;Der Funktion stehen spezielle Variablen (u.a. NEW/OLD) zur Verfügung.;Die Funktion muss NULL zurückgeben.;Keine der genannten Antworten.;123;;Die Trigger-Funktion muss entweder NULL oder einen Wert, der genau der Struktur der Tabelle entspricht, zurückgeben.
(86) Was gilt für die CREATE Statements auf dem Bild?;Die 'id' in 'item' darf NULL sein.;Die Tabelle 'zutat' darf vor 'item' erzeugt werden.;Die Tabelle 'zutat' darf vor 'artikel' erzeugt werden.;Die Relation 'besteht_aus' hat zwei Fremdschlüssel.;Keine der genannten Antworten.;34;j5-1.jpg;Kein Schlüssel darf NULL sein. Die Tabelle 'zutat' muss nach 'item' definiert werden, da der Schlüssel 'id' den Schlüssel von 'item' referenziert.
(87) Was gilt für die Fragestellung und die CREATE Statements im Bild?;CREATE CONSTRAINT ck_bestand CHECK (bestand >= 0);ALTER CONSTRAINT ck_bestand CHECK (bestand >= 0);CREATE TRIGGER AFTER UPDATE ON item CHECK (bestand >= 0);ALTER TABLE item ADD CONSTRAINT ck_bestand CHECK (bestand >= 0);Keine der genannten Antworten.;4;j5-2.jpg;
(88) Wie würde man 'CDTYPE' im Bild korrekt definieren?;INSERT INTO CD ENUM CDTYPE  ('Single', 'Album');INSERT INTO CD ENUM type=CDTYPE  ('Single', 'Album');CREATE TYPE CDTYPE AS ENUM ('Single', 'Album');CREATE ENUM CDTYPE  ('Single', 'Album');Keine der genannten Antworten.;3;j6-1.jpg;
(89) Wie würde man korrekt eine Reihe in der Tabelle 'CD' im Bild einfügen?;INSERT INTO CD VALUES   ('Deltron 3030', '1', 'Album', '75 Ark');INSERT INTO CD VALUES   ('Deltron 3030', 1, 'Album', '75 Ark');INSERT CD (name='Deltron 3030', nr='1', type='Album', label='75 Ark');INSERT CD (name='Deltron 3030', nr=1, type='Album', label='75 Ark');Keine der genannten Antworten.;2;j6-1.jpg;Für die Datentypen Char und Enumeration braucht man das Hochkomma Symbol ('). Das Symbol ist aber für die Typen Integer und Number nicht zu verwenden.
(90) Wie erstellt sich eine Transaktion beim Einfügen der (Test)daten?;Normalerweise automatisch nach jedem Einfügen.;Manuell durch die Befehle 'BEGIN' und 'END'.;Manuell durch die Befehle 'BEGIN' und 'COMMIT'.;Manuell durch die Befehle 'TRANSACTION' und 'COMMIT'.;Keine der genannten Antworten.;13;;Wenn man die Transaktion nicht nach jedem Einfügen committen lassen soll (was sonst passieren würde), um z.B. mit zyklischen Abhängigkeiten umzugehen, kann man manuell eine Transaktion definieren. Der Beginn ist durch den Befehl BEGIN und das Ende durch COMMIT definiert.
(91) Was macht der Befehl 'DEFERRABLE INITIALLY DEFERRED'?;Er hilft bei kaskadierendem Löschen.;Er hilft bei zyklischen Abhängigkeiten.;Er verzögert die Überprüfung der Bedingung bis zum Ende der Datenbankerstellung.;Er verzögert die Überprüfung der Bedingung bis zum Ende der Transaktion.;Keine der genannten Antworten.;24;;
(92) Gibt es im SQL-Code auf dem Bild syntaktische Fehler?;Ja, nach FROM muss eine Relation und kein View vorkommen.;Ja, der Typ von JOIN ist nicht gegeben.;Ja, tid darf nicht sowohl in SELECT, als auch in GROUP BY vorkommen.;Nein, der Code ist korrekt.;Keine der genannten Antworten.;4;j7-1.jpg;Die View 'TourG' ermittelt die Gebühr einer Tour, die der Summe der Gebühren der Häfen, die im Rahmen dieser Tour angefahren werden, entspricht.
(93) Gibt es im SQL-Code auf dem Bild syntaktische Fehler?;Ja, in GROUP BY sollte 'c.name' statt 'name' stehen.;Ja, es ist nicht spezifiziert, wie t und l gejoint werden müssen.;Ja, es ist nicht eindeutig, woher 'dauer' stammt.;Nein, der Code ist korrekt.;Keine der genannten Antworten.;2;j7-2.jpg;In Postgres muss man nach dem JOIN angeben, welche Spalten zu vergleichen sind. Die Namen der Spalten schreibt man nach dem Schlüsselwort ON. Alternativ könnte man z.B. CROSS JOIN verwenden, um das Kreuzprodukt der Tabellen zu erzeugen (in MySQL ist JOIN äquivalent zu CROSS JOIN, was in Postgres nicht der Fall ist). Wenn es in den beiden Tabellen Spalten mit denselben Namen gebe, könnte man auch INNER, LEFT OUTER, RIGHT OUTER, oder FULL OUTER JOIN verwenden, ohne das ON explizit zu spezifizieren.
(94) Welche der Antworten enthält keinen syntaktischen Fehler?;1;2;3;4;Keine der genannten Antworten.;14;j7-3.jpg;
(95) Warum würde man Views in PLpgSQL verwenden?;Um Generalisierungen zu erzeugen, ohne das physische Schema zu verändern.;Um sehr häufig durchgeführte Anfragen zu beschleunigen.;Um nützliche Anfragen als virtuelle Tabellen zu speichern.;Um spätere Anfragen zu vereinfachen.;Keine der genannten Antworten.;134;;
(96) Um Tabellen mit zyklischen Abhängigkeiten zu löschen, muss man;die ganze Datenbank löschen.;zuerst folgendes Constraint löschen: ALTER TABLE tablename DROP CONSTRAINT;alle Tabellen in derselben Transaktion durchführen lassen.;das Schlüsselwort 'CASCADE' verwenden: DROP TABLE tablename CASCADE;Keine der genannten Antworten.;24;;Das Löschen der ganzen Datenbank ist natürlich immer eine Möglichkeit. Das ist aber wegen des absurden Verlustes von anderen Daten keine gute Vorgehensweise.
(97) Wenn es keine zyklischen Abhängigkeiten gibt und man mit CASCADE löscht;werden alle Tabellen gelöscht.;wird das Schlüsselwort 'CASCADE' einfach ignoriert.;werden die Tabellen nicht gelöscht.;ist das Benehmen des DBMS nicht definiert.;Keine der genannten Antworten.;2;;Die Tabelle wird also wie gewöhnlich gelöscht.
(98) Wie löscht man ein View 'v' aus einer Datenbank?;DROP VIEW v;DELETE VIEW v;DELETE TABLE v;Views löschen sich automatisch.;Keine der genannten Antworten.;1;;
(99) Was sind implizite Anforderungen an die Datenintegrität?;Schlüssel.;Beziehungskardinalitäten zwischen Relationen.;Attributdomänen.;Inklusion bei Generalisierung.;Keine der genannten Antworten.;1234;;Schlüssel müssen innerhalb einer Relation eindeutig sein. Von den Beziehungskardinalitäten dürfen Relationen nicht abweichen. Attributdomänen legen die Wertebereiche der Daten fest. Inklusion bei Generalisierung bedeutet, dass Entitäten der Untertypen  auch in Obertypen enthalten sein müssen.
(100) Wie kann man die Erfüllung statischer Integritätsbedingungen in SQL prüfen?;Durch das Schlüsselwort 'INTEGRITY'.;Durch das Schlüsselwort 'DEFERRABLE'.;Durch das Schlüsselwort 'CHECK'.;Durch das Schlüsselwort 'CONSTRAINT'.;Keine der genannten Antworten.;3;;Ein Beispiel wäre: CREATE TABLE Studenten (MatrNr INTEGER PRIMARY KEY, Name VARCHAR(30) NOT NULL, Semester INTEGER CHECK (Semester BETWEEN 1 AND 13))
