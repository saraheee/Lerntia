(1) Welche der folgenden Aussagen über Transparenz (Transparency) sind richtig?;Transparenz wird durch das Verstecken von unterschiedlichen Aspekten eines Systems vom Server erreicht.;Transparenz kann erreicht werden, indem interne Strukturen vom User versteckt werden.;Replikationstransparenz ist eine Vorbedingung für Ortstransparenz.;In Replikationstransparenz wird versteckt, dass eine Ressource gleichzeitig von anderen genutzt wird.;Keine der genannten Antworten.;2;;
(1) Was trifft auf Schichtenarchitekturen (Layered architectures) zu?;Client-Server Architektur ist eine Form der Schichtenarchitektur.;Bei der 3-Schichten Architektur übernimmt die Middleware die Logik und kommuniziert mit dem Client.;Eine Alternative zur Client-Server Architektur ist die horizontale Verteilung (horizontal distribution).;Schichtenarchitektur ist auch als objektbasierte Architektur bekannt.;Keine der genannten Antworten.;12;;
(1) Was bedeutet Offenheit (Openness)?;Offenheit heißt, Dienste mit Standardregeln anzubieten.;Offenheit ist in Zugangspunkten (Gateways) formalisiert.;Offenheit kann über Schnittstellen (Interfaces) erreicht werden.;Je höher die Offenheit, desto niedriger ist die Flexibilität eines Systems.;Keine der genannten Antworten.;13;;
(1) Welche der folgenden Aussagen über Abstraktion (Abstraction) sind richtig?;Abstraktion wird durch das Verstecken von älteren Aspekten eines Systems vom Server erreicht.;Abstraktion wird in Protokollen formalisiert.;Abstraktion heißt, die Realität so zu zerlegen, dass alle Details besser verstanden werden können.;Abstraktion kann durch das Verstecken von Informationen (Encapsulation) erreicht werden.;Keine der genannten Antworten.;5;;
(1) Welche der folgenden Aussagen über das Separieren von Anliegen (Separation of concerns) sind richtig?;Es kann erreicht werden, indem sich in einem Verteiltes System bestimmte Teile nur um ihre Pflichten kümmern.;Client-Server-Architektur ist eine Form des Separierens der Anliegen.;Es kann mithilfe der Unterteilung in Schichten (Layers) erreicht werden.;Es kann mittels Semaphoren implementiert werden.;Keine der genannten Antworten.;123;;
(1) Was bedeutet Skalierbarkeit (Scalability)?;Ein verteiltes System heißt skalierbar, wenn es die Möglichkeit zu wachsen hat.;Skalierbarkeit enthält mehrere Dimensionen.;Skalierbarkeit kann unabhängig von der Effektivität eines Systems betrachtet werden.;Eine Herausforderung der Skalierung ist die Kostenkontrolle.;Keine der genannten Antworten.;124;;
(1) Welche der folgenden Aussagen über QoS (Quality of Service) sind richtig?;Es handelt sich um ein Konzept, mit dem Clients die benötigten Niveaus der Dienste angeben können.;Durch hohes QoS kann man alle Kompromisse vermeiden.;QoS eines Systems ist mit der Anzahl der Administratoren direkt verbunden.;QoS ist durch alle funktionalen und nicht-funktionalen Systemanforderungen definiert.;Keine der genannten Antworten.;1;;
(1) Was sind Annahmen von dezentralisierten Algorithmen?;Keine einzige Maschine hat alle Zustandsinformationen eines Systems.;Maschinen treffen ihre Entscheidungen basierend nur auf lokalen, also umgebenden, Informationen.;Fehlerfall einer Maschine ruiniert den gesamten Algorithmus nicht. Es gibt keinen zentralen Punkt eines Ausfalls.;Es gibt keine impliziten Annahmen, dass eine globale Uhr existiert.;Keine der genannten Antworten.;1234;;
(1) Was sind Beispiele von nichtfunktionalen Anforderungen eines verteilten Systems?;Transparenz;Zuverlässigkeit;Verschlüsselung von Nachrichten;Eine 30-tägige Gratisprobe;Keine der genannten Antworten.;123;;
(1) Was sind Eigenschaften eines jeden verteilten Systems?;Es gibt keine Latenz bzw. Wartezeit.;Die Topologie bzw. Netzstruktur ändert sich nicht.;Es gibt nur einen Administrator.;Das Netzwerk ist homogen.;Keine der genannten Antworten.;5;;
(2) Welche Aussagen zu Prozessen und Threads sind richtig?;Ein Prozess stellt Möglichkeiten zur Verfügung, Instruktionen auszuführen.;Ein Prozess ist eine Hardwareeinheit des Computers.;Ein Prozessor ist ein virtueller oder Software-Prozess.;Ein Thread ist ein maximaler Software-Prozessor.;Keine der genannten Antworten.;5;;Alle falsch. 1. Nein, das ist ein Prozessor. 2. Ebenfalls der Prozessor. 3. Nein, das ist ein Prozess. 4. Nein, minimal. Ein Thread ist die kleinste Einheit, in der Code ausgeführt werden kann.
(2) Welche Aussagen zu Prozessen und Threads sind richtig?;Threads haben einen eigenen Adressraum.;Threads können über einen geteilten Speicherbereich kommunizieren.;Ein Prozess kann beliebig viele Threads enthalten.;Der Prozess-Kontext beinhaltet den Prozessor-Kontext und Thread-Kontext.;Keine der genannten Antworten.;234;;1. Nein, Prozesse haben alle einen eigenen Adressraum, aber Threads in einem Prozess teilen ihn sich. 2. Ja, können sie. Beispielsweise in Java ein Objekt, auf das alle Threads zugreifen. 3. Ja, jeder Prozess hat mindestens einen Thread, aber bis zu beliebig viele. 4. Ja, der Prozessor-Kontext umfasst alle Register, die zum Ausführen einer Reihe von Instruktionen notwendig sind, beim Thread-Kontext und Prozess-Kontext kommt zusätzlich noch der benötigte Speicher hinzu.
(2) Welche Aussagen zu Prozessen und Threads sind richtig?;Software-Prozessoren und virtuelle Prozessoren sind das Gleiche.;Ein Thread ist ein minimaler Software-Prozessor.;Ein Prozess umfasst genau einen Thread.;Ein Thread gehört zu mindestens einem Prozess.;Keine der genannten Antworten.;12;;1. Ja, das haben wir als verschiedene Begriffe fürs Gleiche definiert. 2. Genau. Ein Thread ist die kleinste Einheit, in der Instruktionen bearbeitet werden können. 3. Nein, ein Prozess kann beliebig viele Threads haben. 4. Nein, ein Thread gehört zu genau einem Prozess, mehr geht nicht.
(2) Welche Aussagen zu Prozessen und Threads sind richtig?;Wenn ein Thread in einem Single-Threaded Prozess blockiert, dann blockiert der ganze Prozess.;Wenn ein Thread in einem Multi-Threaded Prozess blockiert, dann blockiert immer der ganze Prozess.;Ein Multi-Threaded Design ist einem Multi-Prozess Design immer vorzuziehen.;Multi-Threaded Programme sind besser parallelisierbar als Single-Threaded Programme.;Keine der genannten Antworten.;14;;1. Ja, stimmt. 2. Nein, nicht immer, hängt davon ab, ob es sich um User-Space oder Kernel-Space Threads handelt. 3. Nein, etwa aus Security-Gründen, weil Prozesse viel besser voneinander isoliert sind. Somit könnten beispielsweise, wenn ein erfolgreicher Angriff auf einen Thread erfolgt, auch Daten aus anderen Threads von anderen Nutzern gestohlen werden. 4. Ja, weil mehrere Threads gleichzeitig auf verschiedenen Prozessoren laufen können.
(2) Welche Aussagen zu Prozessen und Threads sind richtig?;Threads sind immer im Kernel implementiert.;User-Space Threads sind effizienter.;Wenn ein einzelner Thread blockiert, blockiert immer auch der ganze Prozess.;Ein Dispatcher-Thread ist dazu da, Anfragen auf mehrere Threads zu verteilen.;Keine der genannten Antworten.;24;;1. Nein, man kann Threads auch auf User-Space-Seite implementieren, z.B. wie es in Java ist. Es gibt auch noch Mischformen davon. 2. Ja, weil man ohne Prozess-Switch zwischen Threads hin- und herwechseln kann. 3. Nein, nur bei User-Space Threads. 4. Ja, genau das macht ein Dispatcher.
(2) Welche Aussagen zu Virtualisierung sind richtig?;Virtualisierung ist eine Form von Abstraktion von Ressourcen.;Virtualisierung stellt immer eine Schnittstelle zwischen höheren und niedrigeren Schichten zur Verfügung.;Virtualisierung führt immer zu einer höheren Performance für Nutzer.;Virtualisierung führt immer zu einem geringeren Energieverbrauch.;Keine der genannten Antworten.;12;;1. Ja, darum geht es. 2. Ja, etwa virtuelle ISAs (Instuction Set Architectures), um Befehle auf einem virtuellen Prozessor laufen zu lassen, oder eine API zu Programm-Libraries, etc. . 3. Nein, nicht zwangsläufig, wenn Ressourcen geteilt werden, würde das eher die Performance reduzieren als verbessern. Allerdings kann es die Performance verbessern, etwa, wenn Anfragen auf mehr Hardware verteilt werden. 4. Nein, nicht zwangsläufig, weil Virtualisierung eine zusätzliche Abstraktionsschicht einführt, die Arbeit verursacht, so müssen etwa Befehle in einer Java VM zusätzlich noch in Befehle für die Hardware umgewandelt werden. Allerdings kann es den Energieverbrauch verbessern, wenn damit mehrere Dienste auf weniger Hardware laufen können.
(2) Auf welchen Ebenen kann Virtualisierung erfolgen?;Auf der eines Webbrowsers.;Auf der einer Plattform.;Auf der eines Speichers.;Auf der eines Netzwerkes.;Keine der genannten Antworten.;234;;1. Macht keinen Sinn, die anderen sind die Typen, die wir kennengelernt haben.
(2) Welche Aussagen zu Virtualisierung sind richtig?;Process VMs interpretieren oder emulieren Zwischencode, um diesen auszuführen.;VM Monitors interpretieren oder emulieren Zwischencode, um diesen auszuführen.;Process VMs bieten einer virtuellen Umgebung die Instruktionen des Prozessors direkt an.;Process VMs können direkt auf der Hardware, oder in einem Betriebssystem laufen;Keine der genannten Antworten.;1;;1. Genau das sind die Typen. Beispiel für eine Process VM ist etwa Java, wo die Programme erst in einem Bytecode kompiliert werden, um zu laufen, während eine VirtualBox und VMWare VM Monitor sind. 2, 3 und 4 sind falsch: Somit sind 2, 3 jeweils genau der andere Typ, 1 und 2 schließen sich eh gegenseitig aus, 3 gilt für VM Monitors, und 4 genauso.
(2) Welche Faktoren spielen zur Verteilung von Funktionalität auf Clients und Server eine Rolle?;Sicherheit (Security);Performance;Gesetze und Richtlinien;Kosten;Keine der genannten Antworten.;1234;;Alle richtig. 1. Jeder Client könnte möglicherweise manipuliert sein, und vorhandene Checks umgehen. 2. Eine Ausführung beim Client kostet weniger Ressourcen am Server, und umgekehrt. 3. Beispielsweise darf man manche Daten nicht am Server speichern. 4. Aus ähnlichem Grund wie 2: Jede Ausführung beim Client spart Ressourcen am Server, und umgekehrt.
(2) Welche Arten von Transparenz können Client-Server Systeme unterstützen?;Verteilungstransparenz (Distribution Transparency);Finanzielle Transparenz (Financial Transparency);Fehlertransparenz (Failure Transparency).;Sicherheitstransparenz (Security Transparency);Keine der genannten Antworten.;13;;1 ist dazu da, um zu verstecken, ob eine Ressource lokal oder remote benutzt wird. 2 ist Unsinn. 3 ist dazu da, um zu verstecken, ob eine Ressource ausfällt und nicht mehr verfügbar ist, und 4 ist auch Unsinn, da es den Begriff nicht gibt.
(2) Was ist ein Super-Server?;Ein Server mit höherer Performance.;Ein Server, der mehrere Dienste anbietet.;Ein Server, der über mehrere Maschinen verteilt ist.;Ein Server, der nebenläufig ist.;Keine der genannten Antworten.;2;;2. ist korrekt. Alles Andere ist falsch: Performance hat nichts damit zu tun, ein Server selbst kann nicht verteilt sein (das wäre dann ein Cluster), und nebenläufig sind Server heutzutage ohnehin meistens.
(2) Welche Aussagen zu Out-Of-Band Kommunikation sind richtig?;Out-Of-Band Kommunikation ist schneller als herkömmliche Kommunikation.;Out-Of-Band Kommunikation ist dazu da, um dringende Nachrichten auszutauschen.;Out-Of-Band Kommunikation benötigt einen eigenen Port.;Out-Of-Band Kommunikation ist bei manchen Protokollen explizit vorgesehen.;Keine der genannten Antworten.;24;;1. Nein, macht keinen Sinn, sie benutzt ja im Regelfall die gleiche Hardware. 2. Ja, zum Beispiel, um einen fehlerhaften Request abzubrechen, anstatt auf sein Ende zu warten, oder auf einen Fehler, von dem man weiß, dass er nach einer Weile auftreten würde., 3. Nein, das ist nur eine Möglichkeit, es gibt auch andere, z.B. solche, die auf der Transportschicht (Transport layer) durch TCP bereitgestellt werden., 4. Ja, bei FTP zum Beispiel.
(2) Welche Aussagen über Stateful vs. Stateless Server sind richtig?;Stateless Server können durch zusätzliche Daten bessere Ergebnisse liefern.;Stateless Server liefern jedem Client die gleiche Antwort, bei gleichem Request.;Stateless Server funktionieren mit HTTP besser.;Stateless Server können mit Client-Crashes besser umgehen.;Keine der genannten Antworten.;24;;1. Nein, das gilt für die Stateful Server., 2. Stimmt, das ist das entscheidende Kennzeichen, alle Clients sind gleich., 3. Unsinn-Antwort, HTTP alleine hat nichts damit zu tun, ob ein Service stateful oder stateless ist, 4. Ja, weil sie sich nicht ohnehin merken, ob ein Client da ist oder nicht, andernfalls müsste Logik vorhanden sein, die erkennt, wenn ein Client ausgefallen ist, etwa durch Timeouts
(2) Welche Aussagen über Cluster sind richtig?;Cluster sind eine Gruppe von verteilten Servern, die alle die gleiche Aufgabe haben.;Cluster sind notwendig, wenn ein einzelner Server nicht alle Requests bearbeiten kann.;Cluster werden über einen Dispatcher oder logischen Switch mit Anfragen bedient.;Der Dispatcher übernimmt alle Kommunikationen mit dem Client, auch die Antwort.;Keine der genannten Antworten.;123;;1. Ja, das ist praktisch die Definition. 2. Ja, dann muss man Cluster einsetzen. Cluster bringen aber natürlich auch noch andere Vor- und Nachteile, etwa Fehlertoleranz, Komplexität, usw.. 3. Ja, so nennt man das. 4. Nein, der Dispatcher nimmt den Request entgegen, leitet ihn an einen der Server weiter, die ihn beantworten können, und dieser antwortet aber dann direkt, um den Dispatcher als Flaschenhals zu entlasten.
(3) Welche Antwort beschreibt die Schichten des Iso-Osi-Modells in der richtigen Reihenfolge?;Anwendung (Application), Darstellung (Presentation), Sitzung (Session), Sicherung (Data Link), Transport, Netzwerk, Physikalisch;Anwendung (Application), Darstellung (Presentation), Sitzung (Session), Internet, Transport, Sicherung (Data Link), Physikalisch;HTTP, Internet, Transport, Sicherung (Data Link), Physikalisch;Anwendung (Application), Darstellung (Presentation), Sitzung (Session), Transport, Netzwerk, Sicherung (Data Link), Physikalisch;Keine der genannten Antworten.;4;;Antwort 4 ist die Richtige. Zuerst kommen Bits über die Leitung in die Maschine, das entspricht der Physikalischen Schicht (Physical Layer). Damit mehrere Maschinen in einem lokalen Netzwerk Daten austauschen können, brauchen sie ein Netzwerkprotokoll wie etwa Ethernet, was in Schicht 2 (Layer 2) passiert. Dann müssen Maschinen aber auch mit Geräten in anderen Netzwerken kommunizieren können, dafür brauchen sie Routing, um einander zu finden, was in der Netzwerkschicht (Network Layer) passiert. Schließlich brauchen sie Technologien, mit denen festgestellt werden kann, dass die Daten korrekt am anderen Ende ankommen (Transport Layer). Und schlussendlich werden die eingetroffenen Daten eventuell noch an die lokale Maschine angepasst, und von der benutzten Anwendung verarbeitet (Application, Presentation und Session Layer).
(3) Welche Schicht existiert im Iso-Osi Modell nicht?;Anwendungsschicht (Application Layer);Internetschicht (Internet Layer);Physikalische Schicht (Physical Layer);Transportschicht (Transport Layer);Keine der genannten Antworten.;2;;Die Internetschicht (Internet Layer) ist in der vereinfachten Form im TCP-IP Modell enthalten, und entspricht in ihrer Funktionalität der Netzwerkschicht (Network Layer) im Iso-Osi-Modell.
(3) Zu welcher Ebene des Iso-Osi Modells gehört das HTTP-Protokoll?;Anwendungsschicht (Application Layer);Internetschicht (Internet Layer);Physikalische Schicht (Physical Layer);Transportschicht (Transport Layer);Keine der genannten Antworten.;1;;Die Anwendungsschicht (Application Layer), weil damit Daten direkt der Nutzer-Anwendung zugestellt werden.
(3) Zu welcher Ebene des Iso-Osi Modells gehört das IP-Protokoll?;Anwendungsschicht (Application Layer);Physikalische Schicht (Physical Layer);Transportschicht (Transport Layer);Netzwerkschicht (Network Layer);Keine der genannten Antworten.;4;;Die Netzwerkschicht (Network Layer), weil damit Daten zwischen verschiedenen Netzwerken ausgetauscht werden können.
(3) Welche Eigenschaften hat das TCP-Protokoll?;Verbindungslos (Connection-less);Zuverlässig (Reliable);Paket-orientierte Kommunikation (Datagram oriented Communication);Best-Effort Kommunikation;Keine der genannten Antworten.;2;;Nur 2. . Antwort 1 ist falsch, weil TCP sehr wohl Verbindungen aufbaut. 3 ist falsch, weil es um Ströme von Daten, auch über mehrere Pakete hinweg, geht, und 4 ist falsch, weil, wenn es möglich ist, ein Paket immer ankommt. Die Antworten, die in dieser Frage falsch sind, wären alle jeweils für das UDP-Protokoll richtig.
(3) Welche Aussagen zu Middleware sind richtig?;Middleware ist für alle Aufgaben gedacht, die sich nicht auf einer einzelnen Ebene des Iso-Osi-Modells erledigen lassen.;Sie würde im Iso-Osi-Modell zwischen der Transportschicht (Transport Layer) und der Anwendungsschicht (Application Layer) liegen.;Die Middleware umfasst jene Aspekte, die notwendig sind, aber nichts mit Kommunikation zu tun haben, wie Fehlertoleranz, usw.;Middleware bietet eigene Dienste und Protokolle an.;Keine der genannten Antworten.;1234;;Alle richtig. 1. weil eben genau dort alles hinkommt, was sich über mehrere Ebenen des Iso-Osi-Modells erstrecken würde, Security kann z.B. auf mehreren Ebenen sinnvoll sein. 2. Ja, sie muss unter der Anwendungsschicht liegen, damit diese darauf zugreifen kann, steht aber über den Funktionen des Netzwerk-Stacks selbst. 3. Ja, Security, Fehlertoleranz, Skalierung, und mehr. 4. Ja, damit man sie benutzen kann.
(3) Welche Aufgaben gehören zur Middleware?;Kommunikations-Protokolle (Communication protocols);Routing;Sicherheit (Security);Skalierung (Scalability);Keine der genannten Antworten.;134;;Bei Routing geht es um das Auffinden und die Kommunikation zwischen verschiedenen Netzwerken, dafür ist also typischerweise die Netzwerkschicht (Network Layer) zuständig.
(3) Wodurch definiert sich flüchtige (transiente) Kommunikation?;Wenn eine Nachricht nicht zugestellt werden kann, geht sie verloren.;Eine Nachricht wird gespeichert, bis sie zugestellt werden kann.;Der Sender blockiert so lange, bis er eine Antwort bekommt.;Der Sender kann weitere Kommunikationen vornehmen, während er auf eine Antwort wartet.;Keine der genannten Antworten.;1;;Nur 1 ist richtig. 2 wäre das genaue Gegenteil davon, nämlich persistente Kommunikation. Bei 3 und 4 geht es um synchrone vs. asynchrone Kommunikation, das hat mit flüchtiger vs. persistenter nichts zu tun.
(3) Wodurch definiert sich synchrone Kommunikation?;Wenn eine Nachricht nicht zugestellt werden kann, geht sie verloren.;Eine Nachricht wird gespeichert, bis sie zugestellt werden kann.;Der Sender blockiert so lange, bis er eine Antwort bekommt.;Der Sender kann weitere Tätigkeiten vornehmen, während er auf eine Antwort wartet.;Keine der genannten Antworten.;3;;Nur 3 ist richtig. Bei 1 und 2 geht es um transiente vs. persistente Kommunikation, und 4 wäre genau der gegenteilige Fall und würde daher auf asynchrone Kommunikation zutreffen.
(3) Welche Kommunikations-Protokolle können durch eine Middleware erfolgen?;Entfernte Prozeduraufrufe (Remote Procedure Calls);Nachrichtenorientierte Kommunikation (Message-Oriented Communication);HTTP;Multicast Kommunikation (Multicast Communication);Keine der genannten Antworten.;124;;Das sind genau die, die wir ausführlicher besprochen haben. HTTP ist Unsinn.
(3) Welche Aussagen über entfernte Prozeduraufrufe (Remote Procedure Calls) sind richtig?;Sowohl der Client als auch der Server benutzen Stubs.;Der Client benutzt Stubs, der Server braucht allerdings keine.;RPCs sind grundsätzlich asynchron.;RPCs sind grundsätzlich synchron.;Keine der genannten Antworten.;14;;Beide Seiten müssen Stubs verwenden, um kommunizieren zu können. Wenn nur eine Seite den Stub hätte, egal welche, würde die jeweils andere ja dann nicht wissen, wie genau die Nachrichten ausschauen würden. 4. RPCs sind grundsätzlich synchron. Der Client schickt eine Anfrage, und muss warten, bis der Server antwortet. Selbst in der verbesserten, asynchron genannten Variante, muss der Client immer noch auf eine Bestätigung des Servers warten.
(3) Welche Informationen sind notwendig, um Stubs zu erstellen?;Wie die Nachrichten transportiert werden sollen, also etwa über welches Netzwerk-Protokoll.;Wo der Server erreichbar ist, also etwa seine Adresse und Port.;Wie der Server die Nachrichten entgegennimmt, also wie genau die Schnittstelle (Interface) aussieht.;Welches Format die Nachrichten haben sollen, also etwa, wie die Inhalte kodiert sind, als XML, JSON, usw.;Keine der genannten Antworten.;134;;Alle außer 2. Sowohl der Client als auch der Server müssen wissen, wie die Nachrichten ausschauen, wie sie ausgetauscht werden, und wie die Schnittstelle ausschauen muss. 2 aber nicht, um die Stubs zu erstellen, ist das eben nicht notwendig. Dadurch können Server und Clients eben unabhängig ihre Stubs aufbauen, ohne voneinander zu wissen, und können dann, erst später zur Laufzeit, durch eine Middleware miteinander verbunden werden.
(3) Welche Aussagen über nachrichtenorientierte Kommunikation (Message-Oriented Communication) sind richtig?;Sockets sind eine Technologie der Transportschicht (Transport Layer).;Sockets sind eine Technologie der Netzwerkschicht (Network Layer).;Sockets bieten meistens eine persistente Kommunikation.;Sockets bieten meistens eine asynchrone Kommunikation.;Keine der genannten Antworten.;1;;Ja, deswegen gibt es in Java TCP und UDP Sockets. Eine Nutzer-Anwendung arbeitet grundsätzlich in der Applikationsschicht, und muss, um die Netzwerk-Funktionalitäten zu verwenden, auf die darunter liegende zugreifen, und das ist die Transport-Schicht. 2 ist demnach natürlich falsch. 3. ist ebenfalls falsch, wenn ein Socket etwas sendet, und der Empfangspunkt am anderen Ende nicht verfügbar ist, geht die Nachricht verloren. Persistente Kommunikation würde zusätzliche Maßnahmen benötigen, um das zu verhindern. 4. Nein, Sockets können zwar asynchron sein, das Standard-Modell ist aber synchron.
(3) Welche Schritte sind notwendig, um auf Client-Seite einen TCP-Socket zu benutzen?;Der Client muss einen Kommunikationsendpunkt erzeugen (socket());Der Socket wird an eine Adresse gebunden (bind());Der Socket wird angewiesen, nach einkommenden Verbindungen zu lauschen (listen());Der Socket nimmt eine Verbindung an, und baut einen Kommunikationskanal auf (accept());Keine der genannten Antworten.;1;;Nur 1 stimmt für den Client, die anderen Schritte sind auf der Server-Seite notwendig. Die Standard-Socket-Operationen am Server sind socket() bind() listen() und accept(), am Client aber nur socket() und connect(). Zusätzlich gibt es noch die send(), receive() und close() Primitive, die sowohl auf Server- als auch Client-Seite zur Verfügung stehen.
(3) Welche Aussagen über MOMs (Message-Oriented-Middlewares) sind richtig?;MOMs stellen eine synchrone und persistente Kommunikation zur Verfügung.;MOMs werden oft durch Warteschlangen (Queues) umgesetzt.;Die Warteschlangen laufen immer auf der Server-Seite.;MOMs sorgen für bessere Skalierbarkeit, da sie den Server entlasten.;Keine der genannten Antworten.;24;;1. ist falsch, weil MOMs möglichst asynchron und persistent sein sollen. 2. Ja, siehe Beispiele. 3. Nein, man kann es implementieren, wie man will, Warteschlange beim Server, beim Client, oder extra, und alle Varianten haben Vor- und Nachteile. 4. Ja, der Server hat weniger zu tun, weil sich ja eine andere Komponente um das Ausliefern der Nachrichten kümmert.
(3) Welche Operationen unterstützen Warteschlangen (Queues)?;Die Operation 'Put', um neue Nachrichten in die Warteschlange einzustellen.;Die Operation 'Push', um neue Nachrichten zuzustellen.;Die Operation 'Poll', um in Erfahrung zu bringen, ob neue Nachrichten vorhanden sind.;Die Operation 'Receive', um neue Nachrichten abzuholen.;Keine der genannten Antworten.;13;;put' ist der Befehl, mit dem ein Server eine neue Nachricht in die Warteschlange (Queue) einreiht. 'get' ist der Befehl, mit dem ein Client eine Nachricht von der Warteschlange abholt, eine blockierende Aktion. 'poll' ist der Befehl, mit dem ein Client nachfragen kann, ob eine neue Nachricht vorhanden ist, das blockiert nicht. 'notify' ist der Befehl, mit dem die Warteschlange einem Client mitteilen kann, dass eine neue Nachricht vorhanden ist. Die anderen Befehle sind in diesem Kontext nicht definiert.
(3) Welche Aussagen zur Multicast-Kommunikation sind richtig?;Multicasts können als Anwendungslevel (Application-Level) Multicasts durch Overlay Netzwerke implementiert werden;Multicasts sind eine Form von 1-zu-1 Kommunikation.;Multicasts können durch Flooding umgesetzt werden.;Gossiping ist eine weitere Möglichkeit, Informationen durch Multicasts in Peer-to-peer Netzwerken zu verbreiten.;Keine der genannten Antworten.;134;;1. Ja, das geht. In einem Peer-to-Peer Netzwerk kann man so eine Nachricht an alle anderen Netzwerk-Teilnehmer schicken. 2. ist falsch. Es geht immer darum, eine Nachricht gleich an mehrere Empfänger zuzustellen, also handelt es sicht um 1-to-n oder 1-to-many Kommunikation. 3. Richtig, dann bekommen eben alle Peers die Nachricht. 4. Ja, das ist effizienter, weil dann nicht alle Peers eine Nachricht bekommen müssen, aber genau das ist auch der Nachteil, nicht alle Peers bekommen dabei die Nachricht.
(4) Was sind die Vorteile von rekursiver Benennung gegenüber iterativer Benennung?;Der Client muss nur eine Anfrage senden, da er die Antwort immer vom Wurzelserver (Root server) bekommt.;Rekursive Benennung ist günstiger auf der Serverseite.;Rekursive Benennung ermöglicht Caching.;Rekursive Benennung ist besser geeignet für Anfragen über lange Weiten.;Keine der genannten Antworten.;134;;
(4) Welche der folgenden Aussagen über den Namensraum (Name space) sind richtig?;Namensraum ist eine beliebige Abfolge von Bits, die keine besondere Struktur enthält.;Ein Namensraum enthält mehrere Verteilungsschichten.;Ein Namensraum kann mittels eines Graphen modelliert werden.;Namensraum enthält alle gültigen Namen, die von einem Service erkannt werden.;Keine der genannten Antworten.;234;;
(4) Welche der folgenden Aussagen über Namensdomänen (Name domains) sind richtig?;Eine Namensdomäne ist ein Teil eines Namensraums.;Namensdomänen sind Prozesse, die sagen, wie eine Information oder ein Attribut gefunden werden können.;Namensdomänen können durch eine Liste von Objektattributen beschrieben werden.;Eine Namensdomäne hat eine einzige administrative Autorität.;Keine der genannten Antworten.;14;;
(4) Was sind die in der Vorlesung behandelten Ansätze zur Benennung (Naming)?;Flache Benennung;Hierarchische Benennung;Strukturierte Benennung;Attributbasierte Benennung;Keine der genannten Antworten.;134;;
(4) Welche der folgenden Aussagen über LDAP (Lightweight Directory Access Protocol) sind richtig?;LDAP ist eine Implementierung der attributbasierten Benennung.;LDAP ist eine Implementierung der strukturierten Benennung.;LDAP hat eine Baumstruktur, beim Suchen muss man beim Wurzelknoten anfangen.;LDAP ist ein dezentralisierter Verzeichnisdienst.;Keine der genannten Antworten.;1;;
(4) Worum handelt es sich im Bild?;Hierarchischer Lokalisierungsdienst (Hierarchical Location Services);Fingertabelle;Chord Ansatz;Broadcasting;Keine der genannten Antworten.;23;4_1.jpg;
(4) Welche der folgenden Aussagen über Hierarchischen Lokalisierungsdiensten (Hierarchical Location Services - HLS) sind richtig?;HLS sind aufgespannte Suchbäume mit Knoten, die angeben, wo sich Entitäten in einem Verteilten System befinden.;Große Domänen, z.B. ein Netzwerk, werden in verschiedene Unterdomänen aufgeteilt.;HLS kann mehrere Pfadnamen für ein bestimmtes Objekt enthalten, ohne die Hierarchie zu durchbrechen.;Jede Domäne wird mittels genau zwei Knoten repräsentiert.;Keine der genannten Antworten.;2;;
(4) Welche der folgenden Aussagen über attributbasierte Namenssysteme sind richtig?;Sie sind dazu da, um verschiedene Namensräume gleichzeitig durchsuchen zu können.;Sie werden mithilfe von Hashtabellen implementiert.;Ein Verzeichnisdienst ist in der Lage, aufgrund der Attribute, die passenden Entitäten herauszusuchen.;Sie basieren oft auf einem Anfragemechanismus.;Keine der genannten Antworten.;34;;
(4) Welche der folgenden Aussagen sind für das Bild korrekt?;Es handelt sich um ein Beispiel für rekursive Benennung.;Server C enthält den Knoten 'vu'.;Nachricht X ist '[cs]'.;Nachricht Y ist '#[nl,vu,cs,ftp]'.;Keine der genannten Antworten.;4;4_2.jpg;
(4) Welche der folgenden Aussagen sind für das Bild korrekt?;Es handelt sich um ein Beispiel für attributbasierte Benennung.;Es handelt sich um eine Hashtabelle.;Die Tabelle repräsentiert eine inkorrekt implementierte Benennung, da die Werte nicht eindeutig sind.;Die Tabelle repräsentiert verschiedene Verteilungsschichten.;Keine der genannten Antworten.;1;4_3.jpg;
(5) Was sind die Ziele von Fehlertoleranz?;Keine Mängel (Faults) in einem System zu haben.;Zu ermöglichen, dass bei Ausfall einer Komponente, auch das Gesamtsystem ausfällt.;Einen Fehlschlag (Failure) durch Redundanz zu maskieren.;Ein höheres Niveau an Zuverlässigkeit (Dependability) zu erreichen.;Keine der genannten Antworten.;34;;
(5) Welche der folgenden Aussagen über Zuverlässigkeit (Dependability) sind richtig?;Zuverlässigkeit ist zwar wichtig, aber oft nicht entscheidend für die Funktionalität eines Verteilten Systems.;Zuverlässigkeit ist in Verteilten Systemen ein essentielles Ziel.;Zuverlässigkeit enthält verschiedene Attribute.;Zuverlässigkeit ist immer leicht zu testen und zu erhöhen.;Keine der genannten Antworten.;23;;
(5) Was sind die Attribute der Zuverlässigkeit (Dependability)?;Verfügbarkeit (Availability);Sicherheit (Security);Integrität (Integrity);Pünktlichkeit (Punctuality);Keine der genannten Antworten.;13;;
(5) Welche der folgenden Aussagen über Mängel, Störungen, und Fehlschläge (Faults, Errors, and Failures) sind richtig?;Ein falscher Parameter ist ein Beispiel eines Fehlschlages.;Ein Mangel ist ein Systemzustand, der direkt einen Fehlschlag aktiviert.;Ein Mangel führt zu einem Fehlschlag, der wiederum in einer Störung resultiert.;Die drei Fehlerarten sind Gefahren für die Zuverlässigkeit (threats to dependability).;Keine der genannten Antworten.;4;;
(5) Welche der folgenden Aussagen über Mängel (Faults) sind richtig?;Mängel sind Situationen, in denen Dienste gar nicht oder inkorrekt angeboten werden.;Mängel sind Fehler, die das System in einen falschen Zustand bringen können.;Die Implementierung von Fehlertoleranz ist eine Möglichkeit, um Mängel aus einem Verteilten System zu eliminieren.;Ein Mangel heißt ruhend (dormant), falls er eine Störung verursacht hat.;Keine der genannten Antworten.;2;;
(5) Was sind Arten der Antwortfehlschläge (Response failures)?;Zeitwahl-Fehlschlag (Timing failure);Wert-Fehlschlag (Value failure);Unterlassungsfehlschlag (Omission failure);Zustandübergangsfehlschlag (State transition failure);Keine der genannten Antworten.;24;;
(5) Was trifft auf das Byzantinische Fehlschlagsmodell (Byzantine failure model) zu?;Fehlschläge (Failures) treten in regulären Intervallen auf.;Es handelt sich um kleinere triviale Mängel (Faults).;In jedem Moment können Fehlschläge (Failures) auftreten, sodass dieselbe Eingabe verschiedene Ergebnisse liefert.;Die Fehlschläge (Failures) treten in zufälligen Momenten auf.;Keine der genannten Antworten.;34;;
(5) Was sind Arten der Redundanz, die für eine Maskierung von Fehlschlägen (Failures) eingesetzt werden?;Physische Redundanz (Physical redundancy);Entwicklungsredundanz (Development redundancy);Zeitliche Redundanz (Time redundancy);Informationsredundanz (Information redundancy);Keine der genannten Antworten.;134;;
(5) Um welche Art von Redundanz handelt es sich beim Beispiel: Einfügen eines Paritätsbits (Parity bit)?;Physische Redundanz (Physical redundancy);Entwicklungsredundanz (Development redundancy);Zeitliche Redundanz (Time redundancy);Informationsredundanz (Information redundancy);Keine der genannten Antworten.;4;;
(5) Ein Backupserver ist ein Beispiel für welche Art von Redundanz?;Physische Redundanz (Physical redundancy);Entwicklungsredundanz (Development redundancy);Zeitliche Redundanz (Time redundancy);Informationsredundanz (Information redundancy);Keine der genannten Antworten.;1;;
(6) Wozu ist Zeitsynchronisation notwendig?;Gerechtigkeit (Fairness);Sicherheit (Security);Verantwortlichkeit (Accountability);Konsistenz (Consistency);Keine der genannten Antworten.;134;;Fairness, z.B. damit man sicherstellen kann, dass jedes Paket nach einer maximalen Zeit beantwortet wird. Sicherheit (Security) hat zumindest nicht direkt etwas damit zu tun, da ein System ohne synchronisierte Zeit dadurch nicht mehr oder weniger sicher ist. Verantwortlichkeit, also um zu wissen, welcher Prozess wann etwas getan hat. Konsistenz, also z.B. die Reihenfolge eines unabhängigen Nachrichtenaustausches in verschiedenen Prozessen, soll gesichert sein.
(6) Welche Aussagen zu physikalischen Uhren sind richtig?;Eine Maschine hat meistens eine lokale Zeit, die der CET (Central European Time) entspricht.;Ein inkludierter Zeitgeber erzeugt einen Interrupt alle 1 Millisekunden, woraus eine Maschine 1 Sekunde berechnet.;Taktgeber sind nicht perfekt, da sie von Umwelteinflüssen abhängen können, wie etwa Temperatur, usw.;Physikalische Uhren müssen immer wieder synchronisiert werden.;Keine der genannten Antworten.;234;;Die lokale Zeit sollte besser der UTC (Universal Coordinated Time) entsprechen und wird dann bei Gebrauch nach Zeitzonen angepasst angezeigt. Die anderen Antworten stimmen.
(6) Welche Aussagen zum Netzwerk Zeitprotokoll (NTP) sind richtig?;Um ihre Zeit zu synchronisieren, fragt eine Maschine einen zentralen Server nach der Uhrzeit.;Wenn die lokale Zeit einer Maschine abweicht, wird sie entsprechend vor oder zurückgestellt.;Die Zeit wird mehrmals abgefragt.;Die Nachricht mit der längsten Round Trip Time (RTT) wird ausgewählt, und daraus die lokale Zeit berechnet.;Keine der genannten Antworten.;13;;2 ist falsch: Man darf die Zeit auf gar keinen Fall zurückstellen, nur vorwärts, sonst kommt es zu Fehlern und komischen Effekten. 4 ist falsch, weil man die Nachricht mit der kürzesten Round-Trip-Time nimmt, um äußerliche Einflüsse zu minimieren.
(6) Welche Aussagen zum Cristian's Algorithmus sind richtig?;Eine Nachricht wird mit der aktuellen, lokalen Zeit versehen und abgeschickt.;Der Server verarbeitet die Nachricht, und antwortet mit seiner eigenen Zeit.;Der Client empfängt die Antwort, und kann daraus die Abweichung seiner lokalen Uhr berechnen.;Das wird mehrfach wiederholt, und die Nachricht mit der kürzesten Round Trip Time (RTT) wird ausgewählt.;Keine der genannten Antworten.;1234;;Stimmt, so läuft der Crisian's Algorithmus ab.
(6) Über das Netzwerk Zeitprotokoll (NTP) ist folgender Austausch im Bild zwischen Client und Server erfolgt. Um wieviel weicht die lokale Zeit nach Cristian's Algorithmus ab?;Theta = 0 Sekunden, also die Zeit stimmt bereits;Theta = 1 Sekunden, also muss die lokale Zeit um eine Sekunde vorgestellt werden;Theta = 2 Sekunden, also muss die lokale Zeit um zwei Sekunden vorgestellt werden;Theta = 3 Sekunden, also muss die lokale Zeit um drei Sekunden vorgestellt werden;Keine der genannten Antworten.;4;6_cristian1.jpg;plus 3 Sekunden ist richtig. Man nimmt das Paket mit der kürzesten Round Trip Time, Nummer 2 braucht nur 2 Sekunden, und die Abweichung ist dann die Differenz zwischen Server- und Clientzeit zum Empfangszeitpunkt, plus die halbe Round Trip Time.
(6) Über das Netzwerk Zeitprotokoll (NTP) ist folgender Austausch im Bild zwischen Client und Server erfolgt. Um wieviel weicht die lokale Zeit nach Cristian's Algorithmus ab?;Theta = plus 2 Sekunden (+2s), also muss die lokale Zeit um zwei Sekunden vorgestellt werden;Theta = minus 2 Sekunden (-2s), also muss die lokale Zeit um zwei Sekunden zurückgestellt werden;Theta = plus 3 Sekunden (+3s), also muss die lokale Zeit um drei Sekunden vorgestellt werden;Theta = minus 3 Sekunden (-3s), also muss die lokale Zeit um drei Sekunden zurückgestellt werden;Keine der genannten Antworten.;5;6_cristian2.jpg;Die Antwort ist keine davon, nämlich minus eine Sekunde: Die kürzeste Round Trip Time steckt im dritten Paket mit 2 Sekunden, und dort ist die Abweichung minus eine Sekunde (Zeitpunkt Server minus Client ist minus 2 Sekunden, plus die halbe RTT, also 1 Sekunde, ergibt minus 1 Sekunde.
(6) Welche Aussagen zum Berkeley Algorithmus sind richtig?;Eine Maschine arbeitet als Koordinator, und schickt allen Clients im Netz eine Nachricht zur Zeitabstimmung.;Alle Clients antworten mit der Differenz ihrer lokalen Zeit zur Serverzeit.;Der Koordinator berechnet den Durchschnitt aus allen, und alle Maschinen passen ihre Zeit danach an.;Somit haben alle Maschinen also immer die UTC (Universal Coordinated Time) Zeit vorliegen.;Keine der genannten Antworten.;123;;1, 2 und 3 sind genau der Ablauf des entsprechenden Algorithmus, aber 4 stimmt sicher nicht, weil die UTC nämlich nie ins Spiel kommt. Am Schluss haben zwar alle Maschinen die gleiche Zeit, aber welche das genau ist, kann man nicht sagen, das kann im Grunde beliebig sein.
(6) Lamports Logische Uhren: Auf welchen der Werte kann Prozess A seine Uhr an der im Bild markierten Stelle setzen?;Auf Wert 7;Auf Wert 8;Auf Wert 9;Auf Wert 10;Keine der genannten Antworten.;234;6_lamport1.jpg;Prozess A bekommt eine Nachricht von Prozess B, der diese zum Zeitpunkt 6 abgeschickt hat. Somit weiß A also, dass an dieser Stelle mindestens Zeitpunkt 7 vorliegen muss. Zusätzlich dazu hat Prozess A aber schon selbst 7 Ereignisse verarbeitet, also muss an dieser Stelle mindestens 8 stehen, kleiner ist nicht mehr erlaubt.
(6) Lamports Logische Uhren: Auf welchen der Werte kann Prozess B seine Uhr an der im Bild markierten Stelle setzen?;Auf Wert 18;Auf Wert 19;Auf Wert 20;Auf Wert 21;Keine der genannten Antworten.;4;6_lamport2.jpg;Prozess B hat zu diesem Zeitpunkt selbst schon 18 Ereignisse verarbeitet, also muss der Wert mindestens 19 sein. Zusätzlich dazu bekommt er eine Nachricht, die Prozess A zum Zeitpunkt 20 losgeschickt hat. Um also eindeutig festzulegen, dass B die Nachricht empfängt, nachdem A sie gesendet hat, muss der Empfangszeitpunkt mindestens um 1 höher sein als der Sendezeitpunkt von A, und somit mindestens 21
(6) Welche Aussagen zum Wechselseitigen Ausschluss (Mutual Exclusion) sind richtig?;Wechselseitiger Ausschluss kann zentralisiert, dezentralisiert, verteilt oder in einem Token Ring Netzwerk erfolgen.;Bei dezentralisiertem Wechselseitigem Ausschluss kann das System durch Ausfall eines einzigen Koordinators zusammenbrechen.;In Token Ring Netzwerken kann es zu Deadlocks kommen.;Starvation tritt nur bei zentralisiertem Wechselseitigem Ausschluss auf.;Keine der genannten Antworten.;1;;Nummer 2 ist falsch, der Vorteil ist ja, dass es keinen zentralen Punkt eines Ausfalls (Single Point of Failure) mehr gibt. Nummer 3 ist falsch, weil immer genau feststeht, welcher Client gerade agieren darf, für Deadlocks müssten mehrere Clients gleichzeitig auf die gleichen Ressourcen zugreifen wollen. 4 ist falsch: Starvation sollte nur bei dezentralisiertem oder Token-Ring Wechselseitigem Ausschluss (Mutual Exklusion) möglich sein. Im ersten Fall, wenn zuviele Clients nach einer Ressource anfragen, und im zweitem Fall, wenn das Token durch einen Absturz (Crash) nie eintrifft. Bei dezentralisiertem Wechselseitigem Ausschluss (Mutual Exclusion) wird Starvation durch eine Warteschlange verhindert, bei zentralisiertem durch den Koordinator.
(6) Wahlalgorithmen: Im Bild sei folgendes Netzwerk gegeben, in dem der Koordinator, Maschine 7, ausfällt. Wer wird durch den Bully-Algorithmus zum neuen Koordinator?;Maschine 3 wird zum neuen Koordinator.;Maschine 4 wird zum neuen Koordinator.;Maschine 5 wird zum neuen Koordinator.;Maschine 6 wird zum neuen Koordinator.;Keine der genannten Antworten.;4;6_bully.jpg;Maschine 6 wird zum neuen Koordinator. Der Bully-Algorithmus heißt deswegen so, weil immer der mit der größten ID gewinnt, unabhängig davon wer die Wahl startet.
(6) Total geordnetes Multicast: Zwei Prozesse haben den im Bild gegebenen Stand in ihren Warteschlangen (Queues). Was muss geschehen, damit Prozess 1 weitermachen kann?;Gar nichts, Prozess 1 kann bereits weitermachen.;Prozess 1 muss Prozess 2 eine weitere Nachricht schicken.;Prozess 1 muss Prozess 2 eine Bestätigung schicken, dass er Nachricht M2 bekommen hat;Prozess 2 muss Prozess 1 eine Bestätigung schicken, dass er Nachricht M1 bekommen hat.;Keine der genannten Antworten.;3;6_totallyorderedmulticast.jpg;Prozess 1 hat die Nachricht M2 von Prozess 2 bekommen. Der kann aber nicht weitermachen, bis er die Bestätigung dafür bekommen hat. Somit muss P1 die Bestätigung verschicken, und in seine Warteschlange (Queue) einreihen, und M2 ist dann komplett in der Warteschlange und kann bearbeitet werden.
(6) Total geordnetes Multicast: Zwei Prozesse haben den im Bild gegebenen Stand in ihren Warteschlangen (Queues). Was muss geschehen, damit Prozess 2 weitermachen kann?;Gar nichts, Prozess 2 kann bereits weitermachen.;Prozess 2 muss Prozess 1 eine weitere Nachricht schicken.;Prozess 1 braucht eine Bestätigung, dass Prozess 2 die Nachricht M2 bekommen hat.;Prozess 2 braucht eine Bestätigung, dass Prozess 1 die Nachricht M2 bekommen hat.;Keine der genannten Antworten.;4;6_totallyorderedmulticast.jpg;Prozess 2 hat eine Nachricht M2 an Prozess 1 verschickt. Er kann aber erst weitermachen, wenn er die Bestätigung dafür bekommen hat. Somit muss P1 die Bestätigung verschicken, damit P2 sie in seine Warteschlange einreihen kann, und dann ist M2 komplett in der Warteschlange und kann bearbeitet werden.
(7) Was trifft auf die im Bild dargestellte Sequenz zu?;Sequentielle Konsistenz, da die Reihenfolge 'a vor c' in allen Prozessen gegeben ist.;Kausale Konsistenz, da 'a vor b' und 'a vor c' auf P3 und P4 zutrifft.;Zufallskonsistenz, da die Reihenfolge der Lese- und Schreibzugriffe in allen Prozessen vom Zufall abhängt.;FIFO Konsistenz, da in allen Prozessen 'a vor c' zutrifft.;Keine der genannten Antworten.;24;7_sequenz.jpg;Für sequentielle Konsistenz muss die Reihenfolge der Operationen, als eine Sequenz gesehen, für alle Prozesse gleich sein. Das trifft auf Prozess P3 und P4 nicht zu. Die kausale Relation 'a vor b' und 'a vor c' kann aus P1 und P2 abgeleitet werden. Diese trifft auch auf P3 und P4 zu. Der Begriff Zufallskonsistenz ist frei erfunden. Für FIFO Konsistenz müssen nur Schreibzugriffe im selben Prozess betrachtet werden. Aus den zwei Schreibzugriffen in P1 kann die Relation 'a vor c' abgeleitet werden, welche auch auf alle anderen Prozesse zutrifft.
(7) Welche der nachfolgenden Beschreibungen bezüglich Konsistenzmodelle sind korrekt?;Sequentielle Konsistenz: Die Reihenfolge aller Zugriffe ist für alle Prozesse, als eine Sequenz gesehen gleich.;FIFO Konsistenz: Die Reihenfolge von Schreibzugriffen im selben Prozess, trifft auf alle Lesezugriffe zu.;Kausale Konsistenz: Schreiboperationen in einer potentiell kausalen Beziehung, haben die gleiche Reihenfolge in allen Prozessen.;Wenn Sequentielle Konsistenz nicht gegeben ist, kann Kausale Konsistenz dennoch zutreffen.;Keine der genannten Antworten.;1234;;Alle Antworten sind korrekt.
(7) Was trifft auf Eventuelle Konsistenz (Eventual Consistency) zu?;Nach einer Schreiboperation, werden alle Replikas nur schrittweise konsistent.;Es handelt sich um ein Server-zentriertes Konsistenzmodell mit beschränkter Konsistenzgewährleistung.;Konsistenz wird nur für einen einzelnen Client garantiert, der auf einem verteilten Datenspeicher zugreift.;Ein Zugriff auf dem Datenbestand von verschiedenen Standorten entspricht nicht zwingend dem aktuellen Stand.;Keine der genannten Antworten.;134;;Es handelt sich um ein Client-zentriertes Datenmodell, bei dem davon ausgegangen wird, dass Clients unabhängig voneinander arbeiten und, dass Änderungen an den Daten nur selten erfolgen.
(7) Welche der Aussagen beschreibt die monotone Lesekonsistenz (Monotonic Read Consistency)?;Wenn ein Wert verändert wird, ist sichergestellt, dass nachfolgende Leseoperationen, keinen älteren Wert mehr liefern.;Ein Lesezugriff auf den Datenbestand garantiert, dass nachfolgende Leseoperationen keine älteren Daten liefern.;Wenn ein Lesezugriff auf den Datenbestand erfolgt, wird immer garantiert, dass dieser die aktuellsten Daten liefert.;Es kann nie garantiert werden, dass nachfolgende Leseoperationen keinen älteren Wert liefern.;Keine der genannten Antworten.;2;;Die erste Aussage bezieht sich auf RYW (Read-Your-Writes) Konsistenz während die zweite Aussage Monotone Lesekonsistenz (Monotonic Read Consistency) beschreibt. Die dritte Aussage kann nicht garantiert werden, während die letzte Aussage z.B. im Falle der Monotonen Lesekonsistenz (Monotonic Read Consistency) nicht zutrifft.
(7) Ist für die Sequenz im Bild monotone Schreibkonsistenz (Monotonic Write Consistency) gegeben?;Ja, da zwei Schreiboperationen hintereinander erfolgen.;Ja, da die Schreiboperationen auf unterschiedlichen Datenelementen x stattfinden.;Nein, da zuerst die Schreiboperation im Prozess abgeschlossen werden muss, bevor eine nachfolgende erfolgt.;Nein, da zuerst eine Leseoperation ausgeführt werden muss, bevor eine Schreiboperation erfolgt.;Keine der genannten Antworten.;3;7_konsistenz.jpg;
(7) Welche Aussagen treffen auf Inhaltsverteilung (Content Distribution) zu?;Ein Nachteil von Invalidierung ist, dass es eine hohe Bandbreite erfordert.;Bei Invalidierung wird bei jeder Aktualisierung der gesamte Datensatz an den Client geschickt.;Passive Replikation ist vorteilhaft, wenn viele Schreiboperationen erfolgen und nur wenige Leseoperationen.;Aktive Replikation ist sehr teuer und ineffizient, dafür kann sie immer angewendet werden.;Keine der genannten Antworten.;5;;Bei Invalidierung schickt der Server nur dann Benachrichtigungen an den Client, sobald es eine Aktualisierung (Update) gibt. Der Client kann daher den aktuelleren Wert erst dann vom Server holen, wenn er ihn benötigt. Das hat den Vorteil einer geringeren Bandbreite, da nicht gleich alle Daten übermittelt werden müssen. Bei Passiver Replikation wird bei jeder Aktualisierung der ganze Datensatz an den Client verschickt. Das macht dann Sinn, wenn viele Leseoperationen erfolgen und nur wenige Schreiboperationen nötig sind. Diese Methode führt zu einer hohen Konsistenz, dafür benötigt sie auch eine hohe Bandbreite. Bei Aktiver Replikation werden bei einer Aktualisierung nicht die Daten selbst gesendet, sondern nur die durchzuführenden Operationen, mit denen der Client die Daten selbst erstellen kann. Diese Methode ist effizient und kostengünstig, dafür ist sie nicht immer anwendbar.
(7) Welche der nachfolgenden Aussagen sind korrekt?;Bei Push-basierten Protokollen, fragt der Client den Server regelmäßig nach neuen Änderungen.;Push-basierte Protokolle können mit Multicasting eingesetzt werden, um mehrere Clients auf einmal zu benachrichtigen.;Bei Pull-basierten Protokollen muss ein Client nur bei Bedarf an aktuelleren Daten mit dem Server kommunizieren.;Pull-basierte Protokolle sollten den Push-basierten Protokollen vorgezogen werden, da sie immer eine kürzere Antwortzeit haben.;Keine der genannten Antworten.;23;;Bei Push-basierten Protokollen werden Clients automatisch vom Server benachrichtigt, sobald es Änderungen gibt. Das führt zu einer stärkeren Konsistenz, dafür ist es nicht sehr effizient, wenn es viele Änderungen gibt. Pull-basierte Protokolle führen bei einem Cache-miss zu einer längeren Antwortzeit.
(7) Welche Aussagen treffen auf Vermietungen (Leasing) zu?;Der Server liefert dem Client Aktualisierungen (Updates), solange die Vermietung (Lease) nicht abgelaufen ist.;Die Vermietung (Lease) läuft immer erst dann ab, wenn der Client diese kündigt.;Wenn die Vermietung (Lease) abläuft, muss der Client Aktualisierungen (Updates) selbst holen.;Wenn die Vermietung (Lease) abläuft, muss der Client diese verlängern.;Keine der genannten Antworten.;13;;Abhängig von der Art der Vermietung läuft diese ab, wenn sich ein Objekt ständig ändert, wenn ein Objekt nur selten vom Client angefragt wird, oder wenn ein Server belasteter wird.
(7) Was trifft auf altersbasierte Vermietung (Age-based lease) zu?;Die Vermietung wird verlängert, wenn sich ein Objekt für einen längeren Zeitraum nicht verändert.;Die Vermietung wird verlängert, wenn ein Objekt schon sehr alt ist und sich ständig ändert.;Die Vermietung wird verlängert, je häufiger ein Objekt von einem Client angefragt wird.;Die Vermietung wird verlängert, je belasteter ein Server ist.;Keine der genannten Antworten.;1;;Altersbasierte Vermietung (Age-based lease) verlängert die Vermietung, wenn sich ein Objekt für einen längeren Zeitraum nicht verändert hat. Frequenzbasierte Vermietung (Renewal-frequency based lease) verlängert die Vermietung, je häufiger ein Objekt von einem Client angefragt wird. Statusbasierte Vermietung (State-based lease) verkürzt den Zeitraum der Vermietung, je belasteter ein Server ist.
(7) In welcher Reihenfolge werden die im Bild mittels A bis E gekennzeichneten Schritte beim Primären Backup (Primary backup) Protokoll für einen Schreibzugriff durchgeführt?;A, B, C, D, E;A, D, C, E, B;A, D, B, C, E;A, C, E, D, B;Keine der genannten Antworten.;4;7_primary.jpg;A: Ein Client, der einen Schreibzugriff ausüben möchte, schickt eine Anfrage an einem Server. C: Der Server leitet die Anfrage weiter an den Primären Server (Primary server). E: Der Primäre Server (Primary server) schickt allen anderen Servern eine Nachricht, um eine Aktualisierung (Update) durchzuführen. D: Die anderen Server bestätigen die Aktualisierung (Update). B: Der Primäre Server (Primary server) bestätigt die Vollendung der Schreiboperation.
(7) Welche Aussagen treffen auf Quorum-basierte Protokolle zu?;Um Schreibkonflikte zu vermeiden, muss auf weniger als die Hälfte aller Knoten geschrieben werden.;Um starke Konsistenz zu erreichen, muss mindestens ein Server sowohl dem Lese- als auch dem Schreib- Quorum angehören.;Wenn in Summe 5 Server vorhanden sind, muss ein Client, der einen Schreibzugriff ausführen möchte, mindestens 3 davon kontaktieren.;Ein Vorteil ist, dass der Client immer nur einen einzelnen Server kontaktieren muss, um eine Schreiboperation durchzuführen.;Keine der genannten Antworten.;23;;Um Schreibkonflikte zu vermeiden, muss auf mehr als die Hälfte der Knoten geschrieben werden.
(8) Was sind die Vorteile von Replikation?;Fehlertoleranz, wenn eine Komponente ausfällt.;Weniger Speicherplatzbedarf, wenn mehrere Kopien existieren.;Schnellere Zugriffszeit, wenn Daten in der Nähe liegen.;Einfachere Konsistenz, weil alle Daten immer aktuell sind.;Keine der genannten Antworten.;13;;
(8) Um welches Modell handelt es sich im Bild?;Hochladen - Herunterladen Modell (Upload-Download Model);Transparenz Zugriffsmodell (Transparency Access Model);Entferntes Hochladen Modell (Remote Upload Model);Entferntes Zugriffsmodell (Remote Access Model);Keine der genannten Antworten.;1;8_modell1.jpg;
(8) Um welches Modell handelt es sich im Bild?;Hochladen - Herunterladen Modell (Upload-Download Model);Transparenz Zugriffsmodell (Transparency Access Model);Entferntes Hochladen Modell (Remote Upload Model);Entferntes Zugriffsmodell (Remote Access Model);Keine der genannten Antworten.;4;8_modell2.jpg;
(8) Welche Aussagen treffen auf das Entfernte Zugriffsmodell (Remote Access Modell) zu?;Anfragen werden direkt am Server bearbeitet.;Eine Datei wird dem Client übermittelt, und dort bearbeitet.;Wenn zwei Clients gleichzeitig auf eine Datei zugreifen möchten, kann es zu Schreib-Schreib-Konflikten kommen.;Transaktionssemantik kann mit diesem Modell verwendet werden.;Keine der genannten Antworten.;13;;
(8) Welche Aussagen treffen auf das Upload/Download Modell zu?;UNIX Semantik kann mit diesem Modell verwendet werden.;Transaktionssemantik kann mit diesem Modell verwendet werden.;Sitzungssemantik kann mit diesem Modell verwendet werden.;Anfragen werden direkt am Server bearbeitet.;Keine der genannten Antworten.;23;;
(8) Welche Aussagen treffen auf das Google-Dateisystem (Google Filesystem) zu?;Alle Dateien werden in 64MB Chunks geteilt, die auf verschiedenen Servern liegen.;Ein Master ist eine Maschine die weiß, was sich jeweils auf welchem Chunk-Server befindet.;Dateien werden mittels eines Primären Backup Schemas repliziert.;Der Master wartet nur eine Tabelle im Hauptspeicher.;Keine der genannten Antworten.;1234;;Alle Antworten treffen zu.
(8) Welche Aussagen treffen auf Datenaustausch Semantiken (Filesharing Semantics) zu?;Bei der UNIX Semantik liefert eine Leseoperation immer das Resultat der letzten Schreiboperation.;UNIX Semantik kann nur mit dem Upload/Download Modell verwendet werden.;Wenn bei der Transaktionssemantik zwei Clients gleichzeitig einen Schreibzugriff ausführen möchten, so werden die Änderungen der beiden Clients automatisch zusammengefügt und übernommen.;Wenn bei der Sitzungssemantik zwei Clients gleichzeitig einen Schreibzugriff ausführen möchten, so müssen die Änderungen beider Clients verworfen werden.;Keine der genannten Antworten.;1;;
(9) Mit welchen Sicherheitsmechanismen kann man sich vor Sicherheitsbedrohungen schützen?;Verschlüsselung (Encryption), um Daten für einen Attacker unverständlich zu machen.;Authentifizierung (Authentication), um die Identität von einem Subjekt zu überprüfen.;Authorisierung (Authorization), um die Berechtigung eines Subjekts sicherzustellen.;Auditierung (Auditing), um nachzuverfolgen, wer worauf und in welcher Weise zugegriffen hat.;Keine der genannten Antworten.;1234;;Alle Antworten treffen zu.
(9) Welche Sicherheitsbedrohungen könnten auftreten?;Abfangen von versendeten Daten (Interception).;Störung des Datentransfers (Interruption).;Verändern von Nachrichteninhalten (Modification).;Schnelles Versenden von Daten (Rapidity).;Keine der genannten Antworten.;123;;Der vierte Punkt ist frei erfunden. Eine weitere Bedrohung wäre das Einbringen von neuen Daten (Fabrication).
(9) Welche Nachrichten müssen bei einer öffentlich-privaten Schlüssel Authentifizierung (public private key authentication) zwischen Alice und Bob ausgetauscht werden?;Alice sendet eine Challenge RA an Bob, die mit Bobs öffentlichem Schlüssel verschlüsselt ist.;Bob schickt Alice einen geheimen Schlüssel, eine neue Challenge RB und die entschlüsselte Challenge RA.;Bob schickt Alice seinen privaten Schlüssel und die entschlüsselte Challenge RA zurück.;Alice schickt Bob die entschlüsselte Challenge RB zurück, verschlüsselt mit dem geheimen Schlüssel.;Keine der genannten Antworten.;124;;Der private Schlüssel darf nie verschickt werden.
(9) In welchem der drei Schritte im Bild hat sich ein Fehler eingeschlichen?;Im 1. Schritt, da die Challenge RA nicht mit dem öffentlichen Schlüssel verschlüsselt werden sollte.;Im 2. Schritt, da die Challenge RB nicht verschickt werden sollte.;Im 2. Schritt, da statt dem geheimen Schlüssel K AB ein öffentlicher Schlüssel verschickt werden sollte.;Im 3. Schritt, da die Challenge RB unverschlüsselt verschickt werden sollte.;Keine der genannten Antworten.;5;9_public-private.jpg;Im 3. Schritt, da die Challenge RB mit dem geheimen Schlüssel K AB verschlüsselt werden sollte.
(9) Welcher Schritt fehlt im Bild bei 3. bezüglich geheimen geteilten Schlüsseln (Secret shared keys)?;Die Challenges RA und RB müssen beide, mit dem geheimen Schlüssel verschlüsselt, verschickt werden.;Alice muss noch ihre ID verschlüsselt an Bob senden.;Alice muss die Challenge RB mit dem geteilten Schlüssel verschlüsseln, und an Bob senden.;Alice muss die Challenge RB mit ihrem privaten Schlüssel verschlüsseln, und an Bob senden.;Keine der genannten Antworten.;3;9_secret-key.jpg;Die Challenge muss mit dem geheimen geteilten Schlüssel (Secret shared key) verschlüsselt, an Bob geschickt werden.
(9) Bei welchen der Aussagen handelt es sich um Eigenschaften von kryptografischen Funktionen?;Zweiseitige Funktion (Two-way function): Wenn der Output bekannt ist, wird der Input daraus abgeleitet.;Schwache Kollisionsresistenz: Für eine Nachricht ist es sehr schwierig, eine zweite zu finden, die zur gleichen Ausgabe führt.;Starke Kollisionsresistenz: Es ist sehr schwierig, zwei unterschiedlichen Nachrichten zu finden, die dasselbe Resultat liefern.;Eindeutigkeit: Zwei unterschiedliche Inputs liefern nie denselben Output.;Keine der genannten Antworten.;23;;Eine kryptografische Funktion ist eine einseitige Funktion (One-way function), das heißt, dass es schwer ist aus dem Output den dazugehörigen Input zu finden.
(9) Welche Eigenschaften von sicheren Kommunikationskanälen sind korrekt beschrieben?;Authentifikation: Beide Parteien wissen, dass Nachrichten nicht verfälscht werden.;Integrität: Beide Parteien wissen mit wem sie kommunizieren.;Vertraulichkeit: Beide Parteien wissen, dass Nachrichten nicht unberechtigt gelesen werden können.;Sicherheit: Beide Parteien wissen, dass ihre Nachrichten mit Sicherheit vom Empfänger gelesen werden.;Keine der genannten Antworten.;3;;Die Beschreibungen der ersten beiden Antworten sind vertauscht. Die vierte Antwort ist keine Eigenschaft von sicheren Kommunikationskanälen und trifft auch nicht zu.
(9) Wie funktioniert eine DDos Attacke?;Ein Angreifer findet ein Passwort einer Maschine heraus und greift sie damit an.;Ein Angreifer nutzt Schwachstellen aus, um unberechtigt Daten auszulesen.;Ein Angreifer verändert die Rücksprungadresse, und führt eigenen Code aus.;Ein Angreifer infiziert mehrere Maschinen, die ein bestimmtes Opfer mit mehreren Anfragen überlasten.;Keine der genannten Antworten.;4;;Bei einer DDos Attacke wird ein Virus auf mehreren Maschinen ausgeführt (auch Zombies genannt), sodass diese eine bestimmte Opfer-Maschine angreifen. Das Opfer kann aufgrund von Überlastung keine Services mehr anbieten.
(9) Worum handelt es sich im Bild?;DDos (Distributed Denial of Service);Nachrichten Digest (Message Digest);Öffentlich-private Schlüssel Authentifizierung (Public private key authentication);Verschlüsselung von Nachrichten (Message encryption);Keine der genannten Antworten.;2;9_security.jpg;Nachrichten Digest dient nur dazu, um festzustellen, dass Inhalte einer Nachricht nicht verändert wurden. Eine Verschlüsselung ist hier nicht wichtig, die Nachrichten werden öffentlich verschickt.
(9) Was trifft auf Diffie-Hellman zu?;Es dient zur Erstellung von Schlüsseln.;Beide Parteien erstellen zufällige eine Zahl, die geheim bleibt, und berechnen daraus öffentliche Schlüssel, die sie austauschen.;Ein KDC wird in dieser Methode benötigt, um Schlüssel generieren zu können.;Zum Schluss erhalten beide Parteien zwei unterschiedliche Zahlen für den privaten und öffentlichen Schlüssel.;Keine der genannten Antworten.;12;;Ein KDC wird für Diffie-Hellman nicht benötigt. Nach Berechnung der Modulo Operation, erhalten beide Parteien dieselbe Zahl, welche als geteilter privater Schlüssel (Secret shared key) verwendet werden kann.
(9) Was sind Unterschiede zwischen einer symmetrischen und einer asymmetrischen Kryptografie?;Symmetrische Kryptografie benutzt denselben Schlüssel für die Verschlüsselung und Entschlüsselung.;Asymmetrische Kryptografie verwendet unterschiedliche Schlüssel zum verschlüsseln und entschlüsseln.;Symmetrische Verfahren dienen dazu das Abfangen von Nachrichten zu verhindern.;Asymmetrische Verfahren werden für die Authentifizierung eingesetzt.;Keine der genannten Antworten.;1234;;Alle Antworten treffen zu.
(10) Was trifft auf schnelle Elastizität (Rapid elasticity) zu?;Zusätzlicher Speicher kann bei Bedarf einfach zur Verfügung gestellt werden.;Kapazitäten sind virtuell unlimitiert.;Die Skalierbarkeit ist virtuell unlimitiert.;Der Speicherplatz ist physisch unlimitiert.;Keine der genannten Antworten.;123;;Kapazitäten und Skalierbarkeit sind virtuell unlimitiert, sodass zusätzlicher Speicher einfach verfügbar gemacht werden kann.
(10) Was trifft auf serviceorientierte Architekturen (SOA) zu?;Sie dienen zur Organisation von Software Architekturen.;Softwarekomponenten bieten eine bestimmte Funktionalität an.;Softwarekomponenten sind nie abgeschlossen (self contained).;Softwarekomponenten stellen eine Schnittstelle zur Verfügung.;Keine der genannten Antworten.;124;;Softwarekomponenten sind immer abgeschlossen.
(10) Welcher Begriff fehlt im SOA Dreieck rechts unten anstelle des Fragezeichens?;Service Werber (Service advertiser);Service Käufer (Service buyer);Service Anbieter (Service provider);Service Verbraucher (Service user);Keine der genannten Antworten.;3;10_soa.jpg;Service Anbieter (Service provider) ist der gesuchte Begriff.
(10) Was trifft auf Peer-to-Peer Berechnungen (P2P Computing) zu?;Peers haben keine direkte Verbindung zu einander.;Peers kommunizieren miteinander über einen Koordinator.;Der Koordinator ist der einzige, der direkt Services anbieten darf.;Beim Verschicken von Anfragen und Antworten herrscht eine Asymmetrie, wie beim Client-Server Modell.;Keine der genannten Antworten.;5;;Peers sind alle miteinander verbunden und können direkt kommunizieren und Dienstleistungen anbieten und in Anspruch nehmen. Daher gibt es keine Koordinatoren.
(10) Was sind die Vorteile von Peer-to-Peer Berechnungen (P2P Computing)?;Berechnungen können ausgelagert werden, was sich positiv auf die Kosten auswirkt.;Hohe Erweiterbarkeit: Es ist einfach weitere Ressourcen hinzuzufügen.;Hohe Skalierbarkeit: Das System kann zu einer großen Anzahl an Peers erweitert werden.;Hohe Fehlertoleranz: Wenn ein Peer ausfällt, ist das Gesamtsystem weiterhin funktionsfähig.;Keine der genannten Antworten.;1234;;Alle Aussagen treffen zu.
(10) Was trifft auf Ressourcen Bündelung (Resource pooling) zu?;Es werden weniger Ressourcen verkauft, als physikalisch vorhanden sind, um Backup-Ressourcen zu haben.;Es wird davon ausgegangen, dass alle Maschinen immer ausgelastet sind, da die Nachfrage sehr groß ist.;Ein Vorteil davon ist, dass es zu niedrigeren Kosten führen kann.;Ressourcen werden mehreren Anwendern dynamisch zugeteilt.;Keine der genannten Antworten.;34;;Es werden mehr Ressourcen verkauft, als physikalisch vorhanden sind, da davon ausgegangen wird, dass die Maschinen nie ganz ausgelastet sein werden.
(10) Wozu kann ein Service Broker in serviceorientierten Architekturen (SOA) eingesetzt werden?;Er dient zur Unterbrechung von einem Service, das von der Firma nicht mehr angeboten werden soll.;Er dient als Vermittler zwischen Kunden und Firmen.;Er teilt Kunden die Adresse von einem angebotenen Service mit.;Kunden veröffentlichen darin ihre Wünsche, die von den Firmen umgesetzt werden.;Keine der genannten Antworten.;23;;Service Broker werden von Firmen zur Verfügung gestellt, sodass die Kunden darin nach angebotenen Dienstleistungen suchen können.
(10) Welcher Begriff fehlt im Elastizitätsmodell anstelle des Fragezeichens?;Zeitaufwand: Eine Liste an Features, die nach Zeitaufwand geschätzt ist;Implementierung: Funktionale Anforderungen als Feature-Liste;Umfang: Abgrenzung des Gesamtumfangs auf das Wesentliche;Qualität: Nicht-funktionale Eigenschaften, wie Erreichbarkeit eines Dienstes;Keine der genannten Antworten.;4;10_elasticity.jpg;
(10) Was trifft auf IaaS zu?;Cloud Software wird als Service angeboten.;Cloud Plattform wird als Service angeboten.;Cloud Infrastruktur wird als Service angeboten.;Virtuelle Maschinen und Datenspeicher sind Beispiele dafür.;Keine der genannten Antworten.;34;;SaaS wäre Software, die als Service angeboten wird und bei PaaS wird eine Plattform als Service angeboten.
(10) Was sind die vier Einsatzmodelle (Deployment models) nach NIST?;Private Cloud (Private cloud): Operiert für eine einzige Organisation;Öffentliche Cloud (Public cloud): Offen für jeden mit käuflich erwerbbaren Diensten;Geheime Cloud (Secret cloud): Offen für eine bestimmte geheime Gruppe;Hybride Cloud (Hybrid cloud): Zusammensetzung von mehreren Einsatzmodellen;Keine der genannten Antworten.;124;;Geheime Cloud (Secret cloud) gehört nicht zu den Einsatzmodellen nach NIST. Dafür fehlt die Gemeinschaftliche Cloud (Community cloud), die von mehreren Organisationen geteilt wird.
