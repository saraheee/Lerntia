(47) Welche Aussagen über Abhängigkeitstreue und Verlustlosigkeit sind wahr?;Verlustlosigkeit heißt: Bei der Zerlegung eines Schemas müssen die Schlüssel gleich bleiben.;Abhängigkeitstreue heißt: Bei der Zerlegung eines Schemas müssen alle FDs erhalten bleiben.;Verlustlosigkeit heißt: Beim Join der Teil-Schemata muss das originale Schema wiederherstellbar sein.;Eine Zerlegung eines Schemas in 3NF ist immer abhängigkeitstreu.;Keine der genannten Antworten.;234;;Schlüssel können sich ändern. Das sind genau die Definitionen von Abhängigkeitstreue und Verlustlosigkeit. .... Und Zerlegungen in 3NF sind immer abhängigkeitstreu, Zerlegungen in BCNF aber nicht.
(48) Welche Aussagen über Abhängigkeitstreue und Verlustlosigkeit sind wahr?;Man kann jedes Schema durch Zerlegung in 3NF bringen.;Eine Zerlegung eines Schemas in 3NF ist immer verlustlos.;Am Ende einer Zerlegung gibt es so viele Teil-Schemata, wie es vorher Schlüssel gibt.;Eine Zerlegung eines Schemas in BCNF ist immer verlustlos.;Keine der genannten Antworten.;124;;Jedes Schema sollte sich in 3NF zerlegen lassen. Solch eine Zerlegung ist immer verlustlos. .... Darüber, wie viele Teil-Schemata es am Ende gibt, lässt sich so nichts sagen. Es können mehr werden, weil für jeden Schlüssel, der nicht in einem der Teil-Schemata enthalten ist, eine neue erstellt werden muss, andererseits aber redundante Schemata, die bereist in anderen enthalten sind, gekürzt werden können. .... Eine Zerlegung in BCNF muss auch immer verlustlos sein, nur Abhängigkeitstreue ist nicht garantiert.
(49) Welche Aussagen zum Synthesealgorithmus sind wahr?;Zuerst berechnet man die Kanonische Überdeckung.;Für jeden Schlüssel wird ein neues Teil-Schema erstellt.;Für jede FD, die noch nicht in Teil-Schemata existiert, wird ein neues erstellt.;Eliminiere redundante Schemata.;Keine der genannten Antworten.;14;;Man fängt mit der KÜ an, dann wird für jede Funktionale Abhängigkeit ein neues Teil-Schema erstellt, das aus allen Attributen der FD besteht. .... Zusätzlich muss man sicherstellen, dass mindestens ein Schlüssel in einem der neuen Schemata enthalten ist, andernfalls können die Schemata nicht wieder korrekt zusammengejoint werden. Am Schluss werden redundante Schemata gestrichen.
(50) Ist die Zerlegung eines Schemas im Bild in dritte Normalform korrekt?;Ja, das ist korrekt.;Nein, diese Zerlegung wäre nicht abhängigkeitstreu.;Nein, diese Zerlegung wäre nicht verlustlos.;Nein, diese Zerlegung enthält noch zu viel redundante Schemata.;Keine der genannten Antworten.;3;50.png;Nein, das ist nicht korrekt, da fehlt der Schritt, dass ein weiteres Teil-Schema erzeugt werden muss, da keiner der Schlüssel in einem der Teile enthalten sind. Somit ist es nicht möglich, die Teil-Schemata wieder zu einem ganzen zusammenzujoinen, die Aufteilung ist also nicht verlustfrei.
(51) Ist die Zerlegung eines Schemas im Bild in dritte Normalform korrekt?;Ja, das ist korrekt.;Nein, diese Zerlegung wäre nicht abhängigkeitstreu.;Nein, diese Zerlegung wäre nicht verlustlos.;Nein, diese Zerlegung enthält noch zu viel redundante Schemata.;Keine der genannten Antworten.;1;51.png;Ja, hier stimmt alles.
(52) Welche Aussagen über Dekomposition eines Schemas in BCNF sind wahr?;Verlustlosigkeit ist in BCNF garantiert.;Abhängigkeitstreue ist in BCNF garantiert.;Jede FD, die die BCNF verletzt, muss aufgespalten werden.;Man bildet zwei neue Teilschemata aus den Attributen der aufgespaltenen FD.;Keine der genannten Antworten.;13;;Ja, in BCNF gilt Verlustlosigkeit, aber nicht Abhängigkeitstreue. Der Algorithmus geht so vor, dass immer eine Funktionale Abhängigkeit aufgespalten wird, so lange, bis es keine FD mehr gibt, die die BCNF verletzt.
(53) Ist die Zerlegung eines Schemas im Bild in BCNF korrekt?;Ja, das ist korrekt.;Nein, die Aufteilung der Attribute des ersten Schemas R1 stimmt nicht.;Nein, die Aufteilung des Attribute des zweiten Schemas R2 stimmt nicht.;Nein, die Schemata müssten noch zusammengefasst werden.;Keine der genannten Antworten.;1;53.png;Ja, hier stimmt alles, das Beispiel ist richtig.
(54) Ist die Zerlegung eines Schemas im Bild in BCNF korrekt?;Ja, das ist korrekt.;Nein, die Aufteilung der Attribute des ersten Schemas R1 stimmt nicht.;Nein, die Aufteilung des Attribute des zweiten Schemas R2 stimmt nicht.;Nein, die Schemata müssten noch zusammengefasst werden.;Keine der genannten Antworten.;3;54.png;Nein, die Aufteilung stimmt nicht. Wenn eine Funktionale Abhängigkeit in zwei aufgeteilt wird, bekommt eine davon alle Attribute der FD, und die zweite bekommt alle Attribute des Schemas außer denen, die nur auf der rechten Seite der FD vorkommen. Die zweite müsste also alle Attribute außer das B haben.
(55) Welche Antworten über Null-Werte in SQL sind richtig?;Unknown AND True ergibt True.;Unknown OR True ergibt True.;Unknown OR Unknown ergibt True.;Unknown AND Unknown ergibt True.;Keine der genannten Antworten.;2;;Jedes Oder mit einem True muss True ergeben, sonst bleibt immer der Unknown Wert erhalten.
(56) Welche der Aussagen ist wahr?;Duplikate in einem Ergebnis werden automatisch eliminiert.;Der RANGE Operator kann verwendet werden, um Werte in einem bestimmten Bereich zu erhalten.;Ein PRIMARY KEY kann auch aus mehrern Spalten bestehen.;Es kann in einer Tabelle mehrere FOREIGN KEYs geben.;Keine der genannten Antworten.;34;;Duplikate werden nicht automatisch eliminiert, das wäre zu teuer, das macht das System nur, wenn man das DISTINCT Keyword verwendet. .... Der Bereichs-Operator heißt nicht RANGE sondern BETWEEN. .... Ja, der PRIMARY KEY kann beliebig viele Spalten umfassen, dann muss er extra definiert werden, sonst kann man ihn auch einfach bei der Definition der Spalte dazuschreiben. .... Ja, es gibt auch mehrere FOREIGN KEYS, andernfalls könnte man ja nicht mehrere Tabellen verlinken.
(57) Welche Aussagen zum WAL-Prinzip sind richtig?;Wenn eine Transaktion Committen will, müssen davor alle ihre Log-Einträge geschrieben worden sein.;Wenn eine Transaktion Committen will, müssen davor alle ihre Speicher-Seiten geschrieben worden sein.;Wenn eine Seite ausgelagert wird, müssen davor alle Log-Einträge, die sie betreffen, geschrieben worden sein.;Die Reihenfolge der Einträge muss immer erhalten bleiben.;Keine der genannten Antworten.;134;;WAL steht für Write-Ahead-Log und betrifft also nur das Log, keine Speicherseiten der Tranksaktionen. .... Antworten eins, drei und vier sind genau die, über die das Write-Ahead-Log definiert war. .... Antwort zwei kann nicht stimmen, da es beim Write-Ahead-Log nur um die Log-Einträge geht, wie der Name schon zeigt, bei der Frage, was mit Speicherseiten geschieht, kann man hingegen Steal vs. Not Steal und Force vs. Not Force zu Rate ziehen.
(58) Es gelte Logische Protokollierung. Welche dieser Log-Einträge im Bild sind korrekt? [Der Inhalt des Hintergrundspeichers wurde zur Vereinfachung weggelassen.];Der Log-Eintrag Nummer 1 in Zeile 1 ist korrekt.;Der Log-Eintrag Nummer 2 in Zeile 2 ist korrekt.;Der Log-Eintrag Nummer 3 in Zeile 3 ist korrekt.;Der Log-Eintrag Nummer 4 in Zeile 4 ist korrekt.;Keine der genannten Antworten.;23;58.png;Es gibt folgende Probleme in der Grafik: .... Zeile 1 ist falsch, am Anfang gibt es noch nichts zum Umkehren, das muss also sicher ein Eintrag mit eckigen Klammern sein. .... Zeile 2 ist in Ordnung, die Transaktion T1 macht gleich ein abort, das Begin of Transaktion wird rückgängig gemacht, das Recovery für T1 ist fertig. .... Zeile 3 ist in Ordnung. .... Zeile 4 stimmt nicht, da versucht der Log-Eintrag auf zwei verschiedene Speicherseiten A und B zuzugreifen. .... Zeile 5 stimmt nicht, da ist die Nummer des Log-Eintrags doppelt vorhanden. .... Zeile 6 ist in Ordnung. .... Zeile 7 stimmt nicht, die letzte Zahl im Log-Eintrag müsste auf den vorigen Eintrag derselben Transaktion verweisen, also für T1 Nummer vier statt fünf. .... Zeile 8 ist in Ordnung. .... Zeile 9 ist in Ordnung. .... Zeile 10 stimmt nicht, dort steht eine physische Protokollierung, es soll aber immer logische sein. .... Zeile 11 ist in Ordnung. .... Zeile 12 ist in Ordnung. .... Zeile 13 ist in Ordnung. .... Zeile 14 ist in Ordnung. .... Zeile 15 stimmt nicht, dort wurde die Redo anstatt der Undo-Operation genommen. .... Zeile 16 stimmt nicht, dort wurden die Werte für den vorigen Log-Eintrag der Transaktion PrevLSN und der Wert für den nächsten Log-Eintrag, den man bearbeiten muss, UndoNextLSN, vertauscht. .... Somit stimmen Zeilen zwei, drei, sechs, acht, neun, elf, zwölf, dreizehn und vierzehn. .... Zeilen eins, vier, fünf, sieben, zehn, fünfzehn und sechzehn enthalten Fehler.
(59) Es gelte Logische Protokollierung. Welche dieser Log-Einträge im Bild sind korrekt? [Der Inhalt des Hintergrundspeichers wurde zur Vereinfachung weggelassen.];Der Log-Eintrag Nummer 4 in Zeile 5 ist korrekt.;Der Log-Eintrag Nummer 5 in Zeile 6 ist korrekt.;Der Log-Eintrag Nummer 6 in Zeile 7 ist korrekt.;Der Log-Eintrag Nummer 7 in Zeile 8 ist korrekt.;Keine der genannten Antworten.;24;59.png;Erklärung siehe vorige Frage.
(60) Es gelte Logische Protokollierung. Welche dieser Log-Einträge im Bild sind korrekt? [Der Inhalt des Hintergrundspeichers wurde zur Vereinfachung weggelassen.];Der Log-Eintrag Nummer 9 in Zeile 10 ist korrekt.;Der Log-Eintrag Nummer 13 in Zeile 14 ist korrekt.;Der Log-Eintrag Nummer 14 in Zeile 15 ist korrekt.;Der Log-Eintrag Nummer 15 in Zeile 16 ist korrekt.;Keine der genannten Antworten.;24;60.png;Erklärung siehe vorige Frage.
(61) Wenn ein DBMS eine Strategie von STEAL und FORCE einsetzt, was muss beim Recovery ausgeführt werden?;Es muss ein Redo ausgeführt werden.;Es muss kein Redo ausgeführt werden.;Es muss ein Undo ausgeführt werden.;Es muss kein Undo ausgeführt werden.;Keine der genannten Antworten.;23;;Steal heißt, alle Seiten dürfen ausgelagert sein, somit kann es also auch sein, dass Seiten von Transaktionen, die nachher abgebrochen werden, bereits geschrieben sind, deswegen muss ein Undo gemacht werden. .... Force heißt, dass alle Seiten am Ende einer erfolgreichen Transaktion geschrieben sein müssen, es können also keine Daten verloren gehen, ein Redo ist nicht notwendig. Entweder eine Transaktion ist erfolgreich abgeschlossen, dann sind ihre Daten sicher im Hintergrundspeicher, oder sie wird abgebrochen, dann ist es egal, die Daten gehen einfach verloren und müssen nicht wieder hergestellt werden. .... Somit ist ein Undo notwendig, ein Redo aber nicht.
(62) Wenn ein DBMS eine Strategie von NOT STEAL und FORCE einsetzt, was muss beim Recovery ausgeführt werden?;Es muss ein Redo ausgeführt werden.;Es muss kein Redo ausgeführt werden.;Es muss ein Undo ausgeführt werden.;Es muss kein Undo ausgeführt werden.;Keine der genannten Antworten.;24;;Not Steal bedeutet, dass keine Seiten einer Transaktion ausgelagert worden sind, es kann also nicht vorkommen, dass Seiten einer Transaktion, die nachher abgebrochen werden muss, schon geschrieben sind. Also braucht man kein Undo. .... Force bedeutet, dass beim Abschluss einer Transaktion alle Speicherseiten geschrieben sind, es kann also nicht vorkommen, dass Seiten einer abgeschlossenen Transaktion noch nicht geschrieben sind. Also braucht man kein Redo. .... Also ergibt sich in dieser Kombination, dass man weder Redo noch Undo braucht.
(63) Welche Eigenschaften erwartet man sich von einem DBMS?;Atomicity.;Consistency.;Integrity.;Durability.;Keine der genannten Antworten.;1234;;Ein DBMS muss ACID einhalten. Dazu gehören Atomicity, also Transaktionen schließen entweder erfolgreich ab, und alle Änderungen finden sich in der Datenbasis, oder gar nicht, dann haben sie gar keinen Einfluss auf die Datenbasis, es darf keine Situation vorkommen, sodass ein Teil-Ergebnis in der Datenbank steht. .... Consistency, also die Daten müssen immer vor und nach einer Transaktion in einem konsistenten Zustand sein. .... Isolation, also nebenläufige Transaktionen dürfen sich gegenseitig nicht beeinflussen. .... Und Durability, sobald eine Transaktion abgeschlossen ist, darf ihr Ergebnis nicht verloren gehen. 
(64) Welche Art von Konflikt kann ein Lost Update hervorrufen?;Lese-Lese Konflikte (R-R).;Lese-Schreib Konflikte (R-W).;Schreib-Lese Konflikte (W-R).;Schreib-Schreib-Konflikte (W-W).;Keine der genannten Antworten.;4;;Lese-Lese Konflikte gibt es nicht, es muss mindestens ein Schreibzugriff für einen Konflikt erfolgen. .... Wenn eine Transaktion schreibt, und dann eine andere Transaktion schreibt, kann es passieren, dass die zweite den Wert des ersten überschreibt. Ein Lost Update kann also nur bei Schreib-Schreib-Konflikten auftreten. .... Zusätzlich gibt es noch Dirty Read, die durch Schreib-Lese-Konflikte entstehen können. .... Und schließlich noch Unrepeatable Read, und Phantomprobleme, die dadurch entstehen können, dass eine Transaktion erst einen Wert liest, der dann von einer anderen Transaktion überschrieben wird, woduch ein erneutes Lesen einen anderen Wert ergeben kann. Phantomprobleme funktionieren ähnlich, nur dass es darum geht, dass zusätzliche Werte eingefügt werden, anstatt bestehende zu ändern.
(65) Welche Probleme kann ein Schreib-Lese-Konflikt hervorrufen?;Ein Schreib-Lese-Konflikt kann zu Lost Updates führen.;Ein Schreib-Lese-Konflikt kann zu einem Dirty Read führen.;Ein Schreib-Lese-Konflikt kann zu Unrepeatable Read führen.;Ein Schreib-Lese-Konflikt kann zu gar keinem Konflik führen.;Keine der genannten Antworten.;2;;Wenn ein Wert erst geschrieben und dann von einer anderen Transaktion gelesen wird, kann es passieren, dass das Lesen einen falschen Wert liefert. Transaktion A startet, und schreibt einen Wert, den Transaktion B liest, so weit so gut, aber wenn Transaktion A abgebrochen wird, hätte Transaktion B einen Wert gelesen, der eigentlich gar nicht in der Datenbank steht. Das nennt man einen Dirty Read.
(66) Betrachte den Serialisierbarkeitsgraphen im Bild. Welche Aussagen können wir über diese erfolgreich abschließenden Transaktion machen?;Es existiert eine rücksetzbare Historie.;Es existiert eine strikte Historie.;Es existiert eine serialisierbare Historie.;Es existiert eine konfliktserialisierbare Historie.;Keine der genannten Antworten.;34;66.png;Eine Historie ist dann konfliktserialisierbar, wenn ihr Serialisierbarkeitsgraph keine Zyklen enthält. .... Wenn keine Transaktion abbricht, dann ist eine konfliktserialisierbare Historie automatisch auch serialisierbar, aber nicht umgekehrt. .... Sonst können wir keine Aussagen alleine über den Graphen machen.
(67) Betrachte das Bild. Welche Aussagen über Deadlocks sind hier richtig?;In diesen Transaktionen wird ein Deadlock durch Preclaiming ausgeschlossen.;In diesen Transaktionen sind keine Maßnahmen notwendig, da es ohnehin nicht zu einem Deadlock kommen kann.;Ein Deadlock könnte hier mittels Wound-Wait Strategie vermieden werden.;Ein Deadlock könnte hier mittels Wait-Die Strategie vermieden werden.;Keine der genannten Antworten.;34;67.png;Preclaiming heißt, dass die Transaktion erst beginnen darf, wenn sie alle benötigten Sperren hält. Das ist hier eindeutig nicht der Fall. .... Weil T1 und T2 jeweils gegenseitig überkeuzte Sperren haben wollen, kann es sehr wohl zu Deadlocks kommen. .... Sowohl die Wound-Wait Strategie als auch die Wait-die Strategie bieten sich hier an, um Deadlocks zu vermeiden. .... In Schritt 7 will T1 eine Sperre haben, die T2 schon hält, und ist dabei die ältere Transaktion. .... Wenn die Wound-Wait Strategie eingesetzt werden würde, würde T2 in Schritt 8 abgebrochen werden, und T1 zuerst fertig laufen, weil T1 die ältere Transaktion ist. .... Wenn die Wait-Die Strategie eingesetzt werden würde, würde zuerst T1 auf die Freigabe der Sperre warten, und T2 weiterlaufen. .... Dann möchte T2 die Sperre von T1 haben, was aber abgelehnt wird, weil T2 die jüngere Transaktion ist, also wäre in der Situation die Transaktion, die die Sperre haben will, die jüngere, und wird also abgebrochen, und T1 bekommt ihre Sperre und läuft fertig durch.
